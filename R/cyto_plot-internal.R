#' cyto_1d_plot
#'
#' Visualise 1-D flow cytometry density distributions.
#'
#' For a complete list of customisation arguments see
#' \code{\link{cyto_1d_plot,flowFrame-method}}.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}} or
#'   \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param ... additional method-specific arguments for cyto_1d_plot.
#'
#' @seealso \code{\link{cyto_1d_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_1d_plot,flowSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
setGeneric(
  name = "cyto_1d_plot",
  def = function(x, ...) {
    standardGeneric("cyto_1d_plot")
  }
)

#' cyto_1d_plot - flowFrame Method
#'
#' Visualise 1-D flow cytometry density distributions for a flowFrame.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param channel name of the channel or marker to be used to construct the
#'   plot.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transformation object will be used internally to ensure that the axes
#'   labels of the plot are appropriately transformed. The transList will NOT be
#'   applied to the flowFrame internally and should be applied to the flowFrame
#'   prior to plotting.
#' @param overlay a \code{flowFrame}, \code{flowSet} or list of
#'   \code{flowFrames} to be overlayed onto the plot.
#' @param gate gate object(s) to be added to plot.  For \code{cyto_1d_plot} only
#'   gate objects of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}} generated by
#'   drawInterval are supported. Multple gates can be supplied either as a
#'   \code{list} or \code{\link[flowCore:filters-class]{filters}} list.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param modal logical indicating whether density should be normalised to mode
#'   and presented as a percentage. Set to \code{TRUE} by default.
#' @param adjust smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of x axis (e.g. c(0,5)).
#' @param title title to use for the plot, set to the name of the sample by
#'   default.
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param density_stack numeric [0,1] indicating the degree of offset for
#'   overlayed populations, set to 0.5 by default.
#' @param density_fill colour(s) used to fill polygons.
#' @param density_alpha numeric [0,1] used to control fill transparency, set to
#'   1 by default to remove transparency.
#' @param density_line_type line type(s) to use for border(s), set to solid
#'   lines by default.
#' @param density_line_width line width for border.
#' @param density_line_col colour(s) for border line, set to "black" by default.
#' @param axes_text_font numeric indicating the font to use for axes, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param axes_text_size character expansion for axis text.
#' @param axes_text_col colour of axis text.
#' @param axes_label_font numeric indicating the font to use for title, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param axes_label_size character expansion for axis labels.
#' @param axes_label_col colour of axis labels.
#' @param title_text_font numeric indicating the font to use for title, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param title_text_size character expansion for plot title.
#' @param title_text_col colour for plot title.
#' @param legend logical indicating whether a legend should be included for
#'   plots including overlays, set to FALSE by default.
#' @param legend_text vector of labels to use for the legend.
#' @param legend_text_font numeric indicating the font to use for labels, set to
#'   1 for plain font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param legend_text_size character expansion for legend text, set to 1 by
#'   default.
#' @param legend_text_col colour of text used in legend, set to \code{"black"}
#'   by default.
#' @param legend_line_col vector of line colours to use for legend.
#' @param legend_box_fill vector of fill colours to use for legend.
#' @param gate_line_col indicates the colour of the gate to be constructed, set
#'   to \code{"red"} by default.
#' @param gate_line_width numeric to adjust line thickness of gates, set to
#'   \code{2.5} by default.
#' @param gate_line_type integer [0,6] which controls the line type, set to
#'   \code{1} to draw solid lines by default.
#' @param label logical indicating whether gated populations should be labelled.
#'   If the names of the populations are supplied as the text.labels argument,
#'   the population name and frequency will be included in the labels, otherwise
#'   only the population frequencies will be included in the labels.
#' @param label_text vector of population names to use in labels.
#' @param label_text_format indicates the type of text to include in the label,
#'   can be either \code{"alias"}, \code{"percent"}, \code{"count"},
#'   \code{c("alias","percent")} or \code{c("alias","count")}. Set to
#'   \code{c("alias","percent")} by default.
#' @param label_text_font numeric indicating the font to use for labels, set to
#'   2 for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param label_text_size character expansion for label text, set to 0.8 by
#'   default.
#' @param label_text_col colour of text used in labels, set to \code{"black"} by
#'   default.
#' @param label_box_alpha numeric controlling backgropund fill transparency of
#'   label boxes, set to 0.6 by default to introduce some transparency.
#' @param border_line_type line type to use for plot border, set to 1 by default
#'   for a sold border.
#' @param border_line_width line width for plot border, set to 1 by default.
#' @param border_line_col line colour for plot border, set to "black" by
#'   default.
#' @param ... additional arguments passed to \code{\link[graphics:plot]{plot}}.
#'
#' @examples
#' \dontrun{
#' fs <- Activation
#' cyto_1d_plot(fs[[1]], channel = "FSC-A", overlay = fs[[2]], density_fill = c("red", "blue"))
#' }
#'
#' @importFrom flowCore exprs parameters
#' @importFrom flowWorkspace pData
#' @importFrom graphics plot axis title abline polygon legend par
#' @importFrom grDevices adjustcolor
#' @importFrom stats density
#'
#' @seealso \code{\link{cyto_1d_plot,flowSet-method}}
#' @seealso \code{\link{plotCyto,flowFrame-method}}
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
setMethod(cyto_1d_plot, signature = "flowFrame", definition = function(x, 
                                                                       channel, 
                                                                       axes_trans = NULL,
                                                                       overlay = NULL, 
                                                                       gate = NULL, 
                                                                       limits = "machine", 
                                                                       popup = FALSE,
                                                                       modal = TRUE, 
                                                                       adjust = 1.5, 
                                                                       xlim = NULL, 
                                                                       ylim, 
                                                                       title, 
                                                                       xlab, 
                                                                       ylab,
                                                                       density_stack = 0.5,
                                                                       density_fill, 
                                                                       density_alpha = 1, 
                                                                       density_line_type = 1, 
                                                                       density_line_width = 1, 
                                                                       density_line_col = "black",
                                                                       axes_text_font = 1,
                                                                       axes_text_size = 1,
                                                                       axes_text_col = "black", 
                                                                       axes_label_font = 1,
                                                                       axes_label_size = 1.1, 
                                                                       axes_label_col = "black", 
                                                                       title_text_font = 2,
                                                                       title_text_size = 1.1, 
                                                                       title_text_col = "black", 
                                                                       legend = FALSE,
                                                                       legend_text, 
                                                                       legend_text_font = 1,
                                                                       legend_text_size = 1,
                                                                       legend_text_col = "black",
                                                                       legend_line_col, 
                                                                       legend_box_fill, 
                                                                       gate_line_col = "red", 
                                                                       gate_line_width = 2.5, 
                                                                       gate_line_type = 1,
                                                                       label = TRUE, 
                                                                       label_text,
                                                                       label_text_format = c("alias", "percent"), 
                                                                       label_text_font = 2,
                                                                       label_text_size = 0.8, 
                                                                       label_text_col = "black", 
                                                                       label_box_alpha = 0.6,
                                                                       border_line_type = 1,
                                                                       border_line_width = 1,
                                                                       border_line_col = "black", ...) {

  
  # Prevent scientific notation on axes
  options(scipen = 999)
  
  # Assign x to fr
  fr <- x
  fr.channels <- BiocGenerics::colnames(fr)

  # Return channel name if marker supplied
  channel <- checkChannels(fr, channels = channel, plot = TRUE)

  # Get X Axis Breaks and Labels from transList if supplied
  xlabels <- axesLabels(x = fr, channels = channel, transList = axes_trans)[[1]]
  
  # Check overlay return list of fowFrames
  if (!is.null(overlay)) {
    overlay <- checkOverlay(x = fr, overlay = overlay)
  }
  
  # number of overlays
  ovn <- length(overlay)

  # Merge fr with overlay if supplied - named list of fr & overlay
  if (!is.null(overlay)) {
    frs <- c(list(fr), overlay)
    names(frs) <- as.vector(sapply(frs, function(fr) fr@description$GUID))
  } else {
    frs <- list(fr)
    names(frs) <- fr@description$GUID
  }

  # Extract information
  fr.data <- flowWorkspace::pData(parameters(fr))
  fr.channels <- BiocGenerics::colnames(fr)

  # Extract data from frs and calculate kernel density
  frs.dens <- .getDensity(x = frs, channel = channel, adjust = adjust, modal = modal, offset = density_stack)

  # Y axis labels
  if (ovn == 0) {
    ylabels <- TRUE
  } else if (ovn != 0 & density_stack == 0) {
    ylabels <- TRUE
  } else if (ovn != 0 & density_stack != 0) {
    ylabels <- FALSE
  }

  # Get y axis values for horizontal lines
  if (density_stack != 0) {

    ofst <- seq(0, ovn * density_stack * 100, density_stack * 100)
    
  } else if (density_stack == 0) {
    
    ofst <- 0
    
  }

  # Title
  if (missing(title)) {
    title <- fr@description$GUID
  }

  # Y Axis Title
  if (missing(ylab) & !modal) {
    ylab <- "Density"
  } else if (missing(ylab) & modal) {
    ylab <- "Density Normalised to Mode (%)"
  }

  # X Axis Title
  if (missing(xlab)) {
    if (!is.na(fr.data$desc[which(fr.channels == channel)])) {
      xlab <- paste(fr.data$desc[which(fr.channels == channel)], channel, sep = " ")
    } else if (is.na(fr.data$desc[which(fr.channels == channel)])) {
      xlab <- paste(channel, sep = " ")
    }
  }

  # Y Axis Limits
  if (missing(ylim)) {
    if (is.null(overlay)) {
      if (modal == FALSE) {
        ylim <- range(frs.dens[[1]]$y)
      } else if (modal == TRUE) {
        ylim <- c(0, 100)
      }
    } else if (!is.null(overlay)) {

      # No offset with overlay y limits c(0,100)
      if (density_stack == 0) {
        ylim <- c(0, 100)
      } else if (density_stack != 0) {

        # Overlays with offset
        ylim <- c(0, (100 + ovn * density_stack * 100))
      }
    }
  }
  
  # X Axis limits
  if (is.null(xlim)) {
    xlim <- suppressWarnings(.getAxesLimits(x = fr, channels = channel, overlay = overlay, limits = limits)[[1]])
  }
  
  # Overlay colours
  cols <- colorRampPalette(c("grey", "bisque4", "brown1", "red", "darkred", "chocolate", "orange", "yellow", "yellowgreen", "green", "aquamarine", "cyan", "cornflowerblue", "blue", "blueviolet", "purple", "magenta", "deeppink"))

  if (missing(density_fill)) {
    density_fill <- cols(length(frs.dens))
  } else if (length(density_fill) < length(frs.dens)) {
    density_fill <- c(density_fill, cols((length(frs.dens) - length(density_fill))))
  } else if (length(density_fill) > length(frs.dens)) {
    density_fill <- density_fill[length(frs.dens)]
  }

  # Border colours
  if (length(density_line_col) == 1) {
    density_line_col <- rep(density_line_col, length(frs.dens))
  } else if (length(density_line_col) < length(frs.dens)) {
    density_line_col <- c(density_line_col, cols((length(frs.dens) - length(density_line_col))))
  } else if (length(density_line_col) > length(frs.dens)) {
    density_line_col <- density_line_col[length(frs.dens)]
  }

  # Border thickness
  if (length(density_line_width) == 1) {
    density_line_width <- rep(density_line_width, length(frs.dens))
  } else if (length(density_line_width) < length(frs.dens)) {
    density_line_width <- c(density_line_width, rep(1, (length(frs.dens) - length(density_line_width))))
  } else if (length(density_line_width) > length(frs.dens)) {
    density_line_width <- density_line_width[length(frs.dens)]
  }

  # Border line type
  if (length(density_line_type) == 1) {
    density_line_type <- rep(density_line_type, length(frs.dens))
  } else if (length(density_line_type) < length(frs.dens)) {
    density_line_type <- c(density_line_type, rep(1, (length(frs.dens) - length(density_line_type))))
  } else if (length(density_line_type) > length(frs.dens)) {
    density_line_type <- density_line_type[length(frs.dens)]
  }

  # Density transparency
  if (length(density_alpha) == 1) {
    density_alpha <- rep(density_alpha, length(frs.dens))
  } else if (length(density_alpha) < length(frs.dens)) {
    density_alpha <- c(density_alpha, rep(1, (length(frs.dens) - length(density_alpha))))
  } else if (length(density_alpha) > length(frs.dens)) {
    density_alpha <- density_alpha[length(frs.dens)]
  }

  # Pop-up
  if (popup == TRUE) {
    checkOSGD()
  }

  # Legend text
  if (missing(legend_text)) {
    legend_text <- names(frs)
  }

  # Plot margins
  .setPlotMargins(x = fr, overlay = overlay, legend = legend, text.legend = legend_text, main = title)

  # Set up empty plot
  if (is.null(xlabels) & ylabels == FALSE) {
    graphics::plot(1, type = "n", yaxt = "n", xlim = xlim, ylim = ylim, axes = TRUE, font.axis = axes_text_font, cex.axis = axes_text_size, col.axis = axes_text_col, ann = FALSE, bty = "n", ...)
    box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
    abline(h = c(0, ofst), col = density_line_col[length(frs.dens):1])
    title(main = title, cex.main = title_text_size, col.main = title_text_col, font.main = title_text_font)
    title(xlab = xlab, font.lab = axes_label_font, col.lab = axes_label_col, cex.lab = axes_label_size)
    title(ylab = ylab, mgp = c(2, 0, 0), font.lab = axes_label_font, col.lab = axes_label_col, cex.lab = axes_label_size)
  } else if (is.null(xlabels) & ylabels == TRUE) {
    graphics::plot(1, type = "n", xlim = xlim, ylim = ylim, axes = TRUE, font.axis = axes_text_font, cex.axis = axes_text_size, col.axis = axes_text_col, ann = FALSE, las = 1, bty = "n", ...)
    box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
    abline(h = c(0, ofst), col = density_line_col[length(frs.dens):1])
    title(main = title, cex.main = title_text_size, col.main = title_text_col, font.main = title_text_font)
    title(xlab = xlab, font.lab = axes_label_font, col.lab = axes_label_col, cex.lab = axes_label_size)
    title(ylab = ylab, mgp = c(3, 0, 0), font.lab = axes_label_font, col.lab = axes_label_col, cex.lab = axes_label_size)
  } else if (!is.null(xlabels) & ylabels == FALSE) {
    graphics::plot(1, type = "n", yaxt = "n", xaxt = "n", xlim = xlim, ylim = ylim, axes = TRUE, cex.axis = axes_text_size, col.axis = axes_text_col, ann = FALSE, bty = "n", ...)
    axis(1, at = xlabels$at, labels = xlabels$label, font = axes_text_font, cex.axis = axes_text_size, col.axis = axes_text_col)
    box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
    abline(h = c(0, ofst), col = density_line_col[length(frs.dens):1])
    title(main = title, cex.main = title_text_size, col.main = title_text_col, font.main = title_text_font)
    title(xlab = xlab, font.lab = axes_label_font, col.lab = axes_label_col, cex.lab = axes_label_size)
    title(ylab = ylab, mgp = c(2, 0, 0), font.lab = axes_label_font, col.lab = axes_label_col, cex.lab = axes_label_size)
  } else if (!is.null(xlabels) & ylabels == TRUE) {
    graphics::plot(1, type = "n", xaxt = "n", xlim = xlim, ylim = ylim, axes = TRUE, xlab = xlab, ylab = ylab, cex.axis = axes_text_size, col.axis = axes_text_col, ann = FALSE, las = 1, bty = "n", ...)
    axis(1, at = xlabels$at, labels = xlabels$label, font = axes_text_font, cex.axis = axes_text_size, col.axis = axes_text_col)
    box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
    abline(h = c(0, ofst), col = density_line_col[length(frs.dens):1])
    title(main = title, cex.main = title_text_size, col.main = title_text_col, font.main = title_text_font)
    title(xlab = xlab, font.lab = axes_label_font, col.lab = axes_label_col, cex.lab = axes_label_size)
    title(ylab = ylab, mgp = c(3, 0, 0), font.lab = axes_label_font, col.lab = axes_label_col, cex.lab = axes_label_size)
  }

  # Add density distributions - reverse plot order and colours
  if (!is.null(overlay) & density_stack == 0) {
    mapply(function(fr.dens, density_fill, density_line_col, density_line_width, density_line_type, density_alpha) {
      polygon(fr.dens, col = adjustcolor(density_fill, density_alpha), border = density_line_col, lwd = density_line_width, lty = density_line_type)
    }, frs.dens, density_fill, density_line_col, density_line_width, density_line_type, density_alpha)
  } else {
    mapply(function(fr.dens, density_fill, density_line_col, density_line_width, density_line_type, density_alpha) {
      polygon(fr.dens, col = adjustcolor(density_fill, density_alpha), border = density_line_col, lwd = density_line_width, lty = density_line_type)
    }, frs.dens[length(frs.dens):1], density_fill[length(frs.dens):1], density_line_col[length(frs.dens):1], density_line_width[length(frs.dens):1], density_line_type[length(frs.dens):1], density_alpha[length(frs.dens):1])
  }

  # Add legend
  if (!is.null(overlay) & legend == TRUE) {

    # Legend position x
    legend.x <- par("usr")[2] + 0.025 * par("usr")[2]

    # Legend position y
    legend.y <- mean(par("usr")[c(3, 4)]) + (((par("usr")[4]) / 21) * 0.5 * length(frs.dens))

    # Legend labels
    legend_text <- legend_text[length(legend_text):1]

    # Legend
    if (!missing(legend_line_col) & missing(legend_box_fill)) {
      
      if(!all(density_alpha == 1)){
        legend_line_col <- mapply(function(legend_line_col, density_alpha){
          adjustcolor(legend_line_col, density_alpha)
        }, legend_line_col, density_alpha)
      }
      
      legend(x = legend.x, y = legend.y, legend = legend_text, col = legend_line_col, lty = density_line_type, lwd = density_line_width, xpd = TRUE, bty = "n", x.intersp = 0.5, cex = legend_text_size, text.col = legend_text_col, text.font = legend_text_font)
    } else if (missing(legend_line_col) & !missing(legend_box_fill)) {
      
      if(!all(density_alpha == 1)){
        legend_box_fill <- mapply(function(legend_box_fill, density_alpha){
          adjustcolor(legend_box_fill, density_alpha)
        }, legend_box_fill, density_alpha)
      }
      
      legend(x = legend.x, y = legend.y, legend = legend_text, fill = legend_box_fill, xpd = TRUE, bty = "n", x.intersp = 0.5, cex = legend_text_size, text.col = legend_text_col, text.font = legend_text_font)
    } else if (missing(legend_line_col) & missing(legend_box_fill)) {
      
      if(!all(density_alpha == 1)){
        fill <- density_fill[length(frs):1]
        fill <- mapply(function(fill, density_alpha){
          adjustcolor(fill, density_alpha)
        }, fill, density_alpha)
      }else{
        fill <- density_fill[length(frs):1]
      }
      
      legend(x = legend.x, y = legend.y, legend = legend_text, fill = fill, xpd = TRUE, bty = "n", x.intersp = 0.5, cex = legend_text_size, text.col = legend_text_col, text.font = legend_text_font)
    }
  }
  
  # Missing labels for plotLabels
  if(missing(label_text)){
    label_text <- NA
  }
  
  # Gates - no overlay
  if (is.null(overlay)) {
    if (!is.null(gate)) {
      plotGates(gate, channels = channel, col.gate = gate_line_col, lwd.gate = gate_line_width, lty.gate = gate_line_type)
    }

    # Labels
    if (!is.null(gate) & label == TRUE) {

      # Population names missing - show percantage only
      suppressMessages(plotLabels(x = fr, channels = channel, alias = label_text, gates = gate, format.text = label_text_format, cex.text = label_text_size, font.text = label_text_font, col.text = label_text_col, alpha = label_box_alpha))
    
    }
    
  } else if (!is.null(overlay) & density_stack != 0 & !is.null(gate)) {
    .gateOverlay(x = fr, channel = channel, overlay = overlay, gates = gate, offset = density_stack, alias = label_text, format.text = label_text_format, cex.text = label_text_size, font.text = label_text_font, col.text = label_text_col, alpha = label_box_alpha, col.gate = gate_line_col, lwd.gate = gate_line_width, lty.gate = gate_line_type)
  }

  # Return options to default
  options(scipen = 0)

  # Return plot margins to default
  par(mar = c(5, 4, 4, 2) + 0.1)
  
})

#' cyto_1d_plot - flowSet Method
#'
#' Visualise 1-D flow cytometry density distributions for a flowSet.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param channel name of the channel or marker to be used to construct the
#'   plot.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transList object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transList will NOT be applied to the
#'   flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param merge a vector of pData variables tomerge samples into groups, set
#'   to NULL by default to prevent merging. To merge all samples set this
#'   argument to "all".
#' @param overlay a \code{flowFrame}, \code{flowSet}, \code{list of flowFrames},
#'   \code{list of flowSets} or \code{list of flowFrame lists} containing
#'   populations to be overlaid onto the plot(s).
#' @param density_stack vector of length 2 indicating offset for samples and number of
#'   samples per plot. Set to \code{c(0,1)} to plot each sample in a separate
#'   panel.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param layout a vector of the length 2 indicating the dimensions of the grid
#'   for plotting \code{c(#rows, #columns)}.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param title vector of titles to use for each plot, set to name of the sample
#'   by default.
#' @param legend_text vector of names to use in the legend if legend is set to
#'   TRUE.
#' @param ... additional arguments passed to
#'   \code{\link{cyto_1d_plot,flowFrame-method}}.
#'
#' @examples
#' \dontrun{
#' fs <- Activation
#' cyto_1d_plot(fs, channel = "FSC-A", legend = TRUE)
#' }
#' 
#' @seealso \code{\link{cyto_1d_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_plot,flowSet-method}}
#'
#' @importFrom flowCore exprs parameters fsApply
#' @importFrom flowWorkspace pData sampleNames
#' @importFrom graphics plot axis title abline polygon legend
#' @importFrom grDevices n2mfrow
#' @importFrom graphics par
#' @importFrom methods as
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
setMethod(cyto_1d_plot, signature = "flowSet", definition = function(x, channel, axes_trans = NULL, merge = NULL, overlay = NULL, density_stack = c(0,1), limits = "machine", xlim = NULL, layout = NULL, popup = FALSE, title = NULL, legend_text = NULL, ...) {

  # Prevent scientific notation
  options(scipen = 999)

  # Assign x to fs
  fs <- x
  fs.channels <- BiocGenerics::colnames(fs)

  # transList
  if (!is.null(axes_trans)) {
    axes_trans <- checkTransList(axes_trans, inverse = FALSE)
  }

  # Check channel
  channel <- checkChannels(x = fs, channels = channel, plot = TRUE)

  # Axes limits
  if (is.null(xlim)) {
    xlim <- suppressWarnings(.getAxesLimits(x = fs, channels = channel, overlay = overlay, limits = limits)[[1]])
  }

  # Pop-up
  if (popup == TRUE) {
    checkOSGD()
  }
  
  # MergeBy
  if (!is.null(merge)) {
    
    # Return list of merge flowFrames
    fr.lst <- .mergeBy(x = fs, mergeBy = merge)
    
    # Check overlay
    if (!is.null(overlay)) {
      
      overlay <- checkOverlay(x = fs, overlay = overlay)

      # list of flowFrame lists to overlay (1 per group)
      overlay <- .mergeOverlay(x = fs, overlay = overlay, mergeBy = merge)
      
    }
    
    # Plot(s)
    if (is.null(overlay) & density_stack[1] == 0) {
      
      # title
      if (is.null(title) & !merge == "all") {
        title <- names(fr.lst)
      } else if (is.null(title) & merge == "all") {
        title <- "Combined Events"
      }
      
      # Plot layout - each group separate panel - no stacking
      layout <- .setPlotLayout(x = fr.lst, mfrow = layout, stack = density_stack)

      print(layout)
      
      mapply(function(fr, title) {
        cyto_1d_plot(x = fr, channel = channel, axes_trans = axes_trans, density_stack = density_stack[1], title = title, xlim = xlim, ...)
      }, fr.lst, title)
      
    } else if (!is.null(overlay) & density_stack[1] == 0) {

      # title
      if (is.null(title)) {
        title <- names(fr.lst)
      }

      # Plot layout - separate panel with overlay
      layout <- .setPlotLayout(x = fr.lst, mfrow = layout, stack = density_stack)

      # Legend text
      if (is.null(legend_text)) {
        legend_text <- c("Base", "Overlay")
      }

      mapply(function(fr, title, overlay) {
        cyto_1d_plot(x = fr, channel = channel, overlay = overlay, axes_trans = axes_trans, density_stack = density_stack[1], title = title, xlim = xlim, text.legend = legend_text, ...)
      }, fr.lst, title, overlay)
      
    } else if (is.null(overlay) & density_stack[1] != 0) {

      # title
      if (is.null(title)) {
        title <- paste(merge, sep = "-")
      }

      # Plot layout - stacking
      layout <- .setPlotLayout(x = fr.lst, mfrow = layout, stack = density_stack)

      # Split fr.lst by density_stack[2]
      if (length(density_stack) == 1) {
        density_stack[2] <- length(fr.lst)
      }

      sp <- rep(1:length(fr.lst), each = density_stack[2], length.out = length(fr.lst))

      lapply(unique(sp), function(x) {

        # Legend text
        if (is.null(legend_text)) {
          legend_text <- names(fr.lst[sp == x])
        }

        # Plot
        cyto_1d_plot(x = fr.lst[sp == x][[1]], overlay = fr.lst[sp == x][2:length(fr.lst[sp == x])], channel = channel, axes_trans = axes_trans, density_stack = density_stack[1], title = title, xlim = xlim, text.legend = legend_text, ...)
      })
      
    } else if (!is.null(overlay) & density_stack[1] != 0) {
      stop("Overlays and stacking are not currently supported. Please remove stacking.")
    }
  
  } else if (is.null(merge)) {

    # Stacking
    if (density_stack[1] != 0) {
      if (length(density_stack) == 1) {
        density_stack[2] <- length(fs)
      } else if (is.na(density_stack[2])) {
        density_stack[2] <- length(fs)
      }
    }
    
    # Number of samples
    smp <- length(fs)

    # Convert fs to list of flowFrames
    fs.lst <- lapply(seq(1, length(fs), 1), function(x) fs[[x]])
    
    # No stacking - each in new plot
    if (density_stack[1] == 0) {

      # Overlays - list containing flowFrame lists
      if (!is.null(overlay)) {
        overlay <- checkOverlay(x = fs, overlay = overlay)
      }

      # Plot layout
      layout <- .setPlotLayout(x = fs, mfrow = layout, stack = density_stack)

      # Plot space
      np <- layout[1] * layout[2]

      # Titles
      if (is.null(title)) {
        title <- sampleNames(fs)
      }
      
      # Plot
      if (!is.null(overlay)) {
        cnt <- 0
        mapply(function(fr, o, title) {
          cnt <<- cnt + 1

          cyto_1d_plot(x = fr, channel = channel, axes_trans = axes_trans, overlay = o, density_stack = density_stack[1], title = title, xlim = xlim, ...)

          if (popup == TRUE & cnt %% np == 0 & length(fs.lst) > cnt) {
            checkOSGD()
          }
        }, fs.lst, overlay, title)
      } else {
        
        # Titles
        if (is.null(title)) {
          title <- sampleNames(fs)
        }
        
        cnt <- 0
        mapply(function(fr, title) {
          cnt <<- cnt + 1
          cyto_1d_plot(x = fr, channel = channel, axes_trans = axes_trans, density_stack = density_stack[1], title = title, xlim = xlim, ...)

          if (popup == TRUE & cnt %% np == 0 & length(fs.lst) > cnt) {
            checkOSGD()
          }
        }, fs.lst, title)
      }

      # Stacking - set stack to zero
    } else if (density_stack[1] != 0) {

      # Stacked overlays not yet supported
      if (!is.null(overlay)) {
        message("Overlays are not supported for stacked samples. Overlay will be ignored during plotting.")
      }

      # split up samples based on density_stack[2]
      nm <- ceiling(length(fs.lst) / density_stack[2])
      fs.lsts <- lapply(seq(density_stack[2], nm * density_stack[2], density_stack[2]), function(x) {
        i <- x - density_stack[2] + 1
        fs.lst[i:x]
      })
      
      # Plot layout
      layout <- .setPlotLayout(x = fs, mfrow = layout, stack = density_stack)

      # Pass first frame to cyto_1d_plot with others as list of frames - popup?
      lapply(fs.lsts, function(fs.lst) {
        
        if(length(fs.lst) == 1){
          
          cyto_1d_plot(x = fs.lst[[1]], channel = channel, axes_trans = axes_trans, title = title, xlim = xlim, ...)
          
        }else{
          
          fr.lst <- fs.lst[2:length(fs.lst)]

          cyto_1d_plot(x = fs.lst[[1]], channel = channel, axes_trans = axes_trans, overlay = fr.lst, density_stack = density_stack[1], title = title, xlim = xlim, ...)

        }
        
      })
    }
  }

  # Return mfrow to default
  if (layout[1] != FALSE) {
    par(mfrow = c(1, 1))
  }

  # Return options to default
  options(scipen = 0)
  
})

#' cyto_2d_plot
#'
#' Visualise 2-D flow cytometry scatterplots with blue-red density colour scale.
#'
#' For a complete list of customisation arguments see
#' \code{\link{cyto_2d_plot,flowFrame-method}}.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}} or
#'   \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param ... additional method-specific arguments for cyto_2d_plot,
#'
#' @seealso \code{\link{cyto_2d_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_2d_plot,flowSet-method}}
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
setGeneric(
  name = "cyto_2d_plot",
  def = function(x, ...) {
    standardGeneric("cyto_2d_plot")
  }
)

#' cyto_2d_plot - flowFrame Method
#'
#' Visualise 2-D flow cytometry scatterplots with blue-red density colour scale
#' for a flowFrame.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param channels name of the channels or markers to be used to construct the
#'   plot.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transList object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transList will NOT be applied to the
#'   flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param overlay a \code{flowFrame} object to be overlayed onto the plot.
#' @param contour_line numeric indicating the number of levels to use for
#'   contour lines, set to 0 by default to turn off contour lines.
#' @param gate gate object(s) to be added to plot. Gates can be of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}},
#'   \code{\link[flowCore:polygonGate-class]{polygonGate}} or
#'   \code{\link[flowCore:ellipsoidGate-class]{ellipsoidGate}}. Multiple gates
#'   of mixed classes can also be supplied in \code{list} or
#'   \code{\link[flowCore:filters-class]{filters}} objects.
#' @param display  numeric indicating the number of events to plot, set to all
#'   events by default. Reducing the sample size can significantly improve
#'   plotting speed on less powerful machines.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of x axis (e.g. c(0,5)).
#' @param title title to use for the plot, set to the name of the sample by
#'   default.
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param point_shape point character to use for points, set to "." by default
#'   to maximise plotting speed.
#' @param point_size numeric specifying the degree of character expansion for
#'   points, set to 2 by default.
#' @param point_col colours to use for points, set to NA by default to blue-red
#'   density colour scale.
#' @param point_alpha numeric [0,1] used to control col transparency, set to 1
#'   by default to remove transparency.
#' @param contour_line_type type of line to use for contour lines, set to 1 by
#'   default.
#' @param contour_line_col colour to use for contour lines, set to "black" by
#'   default.
#' @param contour_line_width line width for contour lines, set to 2 by default.
#' @param axes_text_font numeric indicating the font to use for axes text, set
#'   to 1 for plain font by default. See \code{\link[graphics:par]{?par}} font
#'   for details.
#' @param axes_text_size character expansion for axis text.
#' @param axes_text_col colour of axis text.
#' @param axes_label_font numeric indicating the font to use for axes labels,
#'   set to 1 for plain font by default. See \code{\link[graphics:par]{?par}}
#'   font for details.
#' @param axes_label_size character expansion for axis labels.
#' @param axes_label_col colour of axis labels.
#' @param title_font numeric indicating the font to use for the title, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param title_size character expansion for plot title.
#' @param title_col colour for plot title.
#' @param legend logical indicating whether a legend should be included for
#'   plots including overlays, set to FALSE by default.
#' @param legend_text vector of labels to use for the legend.
#' @param legend_text_font numeric indicating the font to use for legend text,
#'   set to 2 for bold font by default. See \code{\link[graphics:par]{?par}}
#'   font for details.
#' @param legend_text_size character expansion for legend text, set to 1 by
#'   default.
#' @param legend_text_col colour to use for legend text, set to "black by
#'   default.
#' @param legend_line_col vector of line colours to use for legend.
#' @param legend_box_fill vector of fill colours to use for legend.
#' @param gate_line_type integer [0,6] which controls the line type, set to
#'   \code{1} to draw solid lines by default.
#' @param gate_line_width numeric to adjust line thickness of gates, set to
#'   \code{2.5} by default.
#' @param gate_line_col indicates the colour of the gate to be constructed, set
#'   to \code{"red"} by default.
#' @param label logical indicating whether gated populations should be labelled.
#'   If the names of the populations are supplied as the text.labels argument,
#'   the population name and frequency will be included in the labels, otherwise
#'   only the population frequencies will be included in the labels.
#' @param label_text vector of population names to use in labels.
#' @param label_text_format indicates the type of text to include in the label, can
#'   be either \code{"alias"}, \code{"percent"}, \code{"count"},
#'   \code{c("alias","percent")} or \code{c("alias","count")}. Set to
#'   \code{c("alias","percent")} by default.
#' @param label_text_font numeric indicating the font to use for labels, set to
#'   2 for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param label_text_size character expansion for label text, set to 0.8 by
#'   default.
#' @param label_text_col colour of text used in labels, set to \code{"black"} by
#'   default.
#' @param label_box_alpha numeric controlling backgropund fill transparency of
#'   labels, set to 0.6 by default to introduce some transparency.
#' @param border_line_type line type to use for plot border, set to 1 by default
#'   for a sold border.
#' @param border_line_width line width for plot border, set to 1 by default.
#' @param border_line_col line colour for plot border, set to "black" by
#'   default.
#' @param ... additional arguments passed to \code{\link[graphics:plot]{plot}}.
#'
#' @examples
#' \dontrun{
#' fs <- Activation
#' cyto_2d_plot(fs[[1]], channel = c("FSC-A", "SSC-A"), overlay = fs[[2]], point_col = c(NA, "purple"))
#' cyto_2d_plot(fs[[1]], channel = c("FSC-A", "SSC-A"), overlay = fs[[2]], point_col = c("black", "red"))
#' }
#'
#' @importFrom flowCore exprs parameters fsApply
#' @importFrom flowWorkspace pData
#' @importFrom MASS kde2d
#' @importFrom graphics plot axis title abline polygon contour legend points par
#' @importFrom grDevices densCols colorRampPalette adjustcolor
#'
#' @seealso \code{\link{cyto_2d_plot,flowSet-method}}
#' @seealso \code{\link{cyto_2d_plot,flowFrame-method}}
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
setMethod(cyto_2d_plot, signature = "flowFrame", definition = function(x, 
                                                                       channels, 
                                                                       axes_trans = NULL, 
                                                                       overlay = NULL, 
                                                                       contour = 0, 
                                                                       gate = NULL, 
                                                                       display = NULL,
                                                                       popup = FALSE, 
                                                                       limits = "machine", 
                                                                       xlim = NULL, 
                                                                       ylim = NULL,
                                                                       title, 
                                                                       xlab, 
                                                                       ylab, 
                                                                       point_shape = ".", 
                                                                       point_size = 2, 
                                                                       point_col, 
                                                                       point_alpha = 1, 
                                                                       contour_line_type = 1,
                                                                       contour_line_col= "black", 
                                                                       contour_line_width = 1,
                                                                       axes_text_font = 1,
                                                                       axes_text_size = 1, 
                                                                       axes_text_col = "black", 
                                                                       axes_label_font = 1,
                                                                       axes_label_size = 1.1, 
                                                                       axes_label_col = "black", 
                                                                       title_font = 2,
                                                                       title_size = 1.1,
                                                                       title_col = "black", 
                                                                       legend = FALSE, 
                                                                       legend_text,
                                                                       legend_text_font = 1,
                                                                       legend_text_size = 1,
                                                                       legend_text_col = "black",
                                                                       legend_line_col, 
                                                                       legend_box_fill, 
                                                                       gate_line_type = 1,
                                                                       gate_line_width = 2.5, 
                                                                       gate_line_col = "red", 
                                                                       label = TRUE, 
                                                                       label_text, 
                                                                       label_text_format = c("alias", "percent"), 
                                                                       label_text_font = 2,
                                                                       label_text_size = 0.8, 
                                                                       label_text_col = "black", 
                                                                       label_box_alpha = 0.6, 
                                                                       border_line_type = 1,
                                                                       border_line_width = 1,
                                                                       border_line_col = "black", ...) {

  # Prevent scientific notation
  options(scipen = 999)

  # Assign x to fr
  fr <- x
  fr.channels <- BiocGenerics::colnames(fr)

  # Check channels
  channels <- checkChannels(fr, channels = channels, plot = TRUE)

  # X axis limits
  if (is.null(xlim)) {
    xlim <- suppressWarnings(.getAxesLimits(x = fr, channels = channels, overlay = overlay, limits = limits)[[1]])
  }

  # Y axis limits
  if (is.null(ylim)) {
    ylim <- suppressWarnings(.getAxesLimits(x = fr, channels = channels, overlay = overlay, limits = limits)[[2]])
  }

  # subSample
  if (!is.null(subSample)) {
    fr <- sampleFrame(fr, subSample)
  }

  # Get Axis Breaks and Labels from transList if supplied
  axs <- axesLabels(x = fr, channels = channels, transList = transList)
  xlabels <- axs[[1]]
  ylabels <- axs[[2]]

  # overlay
  if (!is.null(overlay)) {
    overlay <- checkOverlay(x = fr, overlay = overlay, subSample = subSample)
  }

  # Number of samples
  if (!is.null(overlay)) {
    smp <- 1 + length(overlay)
  } else {
    smp <- 1
  }

  # Extract data for plotting
  fr.exprs <- flowCore::exprs(fr)[, channels]

  # Extract pData and Channels
  fr.data <- flowWorkspace::pData(flowCore::parameters(fr))

  # Point colour - 2D colour scale
  if (missing(col)) {
    cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
    col.pts <- densCols(fr.exprs[, channels], colramp = cols)

    if (!is.null(overlay)) {
      cols <- colorRampPalette(c("black", "darkorchid", "blueviolet", "magenta", "deeppink", "red4", "orange", "springgreen4"))
      col.overlay <- cols(length(overlay))
    }
  } else if (length(col) == 1) {
    if (is.na(col[1])) {
      cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
      col.pts <- densCols(fr.exprs[, channels], colramp = cols)
    } else {
      col.pts <- col[1]
    }

    if (!is.null(overlay)) {
      cols <- colorRampPalette(c("darkorchid", "blueviolet", "magenta", "deeppink", "red4", "orange", "springgreen4", "navyblue"))
      col.overlay <- cols(length(overlay))
    }
  } else if (length(col) > 1) {
    if (length(col) < length(smp)) {
      if (is.na(col[1])) {
        cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
        col.pts <- densCols(fr.exprs[, channels], colramp = cols)
      } else {
        col.pts <- col[1]
      }
      cols <- colorRampPalette(c("darkorchid", "blueviolet", "magenta", "deeppink", "red4", "orange", "springgreen4", "navyblue"))
      col.overlay <- c(col[2:length(col)], cols((smp - 1) - length(col[2:length(col)])))
    } else if (length(col) > length(smp)) {
      if (is.na(col[1])) {
        cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
        col.pts <- densCols(fr.exprs[, channels], colramp = cols)
      } else {
        col.pts <- col[1]
      }
      col.overlay <- col[2:smp]
    } else {
      if (is.na(col[1])) {
        cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
        col.pts <- densCols(fr.exprs[, channels], colramp = cols)
      } else {
        col.pts <- col[1]
      }
      col.overlay <- col[2:length(col)]
    }
  } else {
    col.overlay <- col[-1]
  }

  # X Axis Title
  if (missing(xlab)) {
    if (!is.na(fr.data$desc[which(fr.channels == channels[1])])) {
      xlab <- paste(fr.data$desc[which(fr.channels == channels[1])], channels[1], sep = " ")
    } else if (is.na(fr.data$desc[which(fr.channels == channels[1])])) {
      xlab <- paste(channels[1], sep = " ")
    }
  }

  # Y Axis Title
  if (missing(ylab)) {
    if (!is.na(fr.data$desc[which(fr.channels == channels[2])])) {
      ylab <- paste(fr.data$desc[which(fr.channels == channels[2])], channels[2], sep = " ")
    } else if (is.na(fr.data$desc[which(fr.channels == channels[2])])) {
      ylab <- paste(channels[2], sep = " ")
    }
  }

  # Title
  if (missing(main)) {
    main <- fr@description$GUID
  }

  # Alpha
  if (length(alpha) == 1) {
    alpha.pts <- alpha[1]

    if (!is.null(overlay)) {
      alpha.overlay <- rep(alpha, length(overlay))
    }
  } else if (length(alpha) < length(smp)) {
    alpha.pts <- alpha[1]
    alpha.overlay <- c(alpha[2:length(alpha)], rep(1, (smp - length(alpha))))
  } else if (length(alpha) > length(smp)) {
    alpha.pts <- alpha[1]
    alpha.overlay <- alpha[2:smp]
  }

  # Pop-up
  if (popup == TRUE) {
    checkOSGD()
  }

  # Legend labels
  if (missing(text.legend)) {
    text.legend <- c(fr@description$GUID, as.vector(sapply(overlay,function(fr){fr@description$GUID})))
  }
  
  # Plot margins
  .setPlotMargins(x = fr, overlay = overlay, legend = legend, text.legend = text.legend, main = main)

  # Plot
  if (nrow(fr) < 2) {
    graphics::plot(1, type = "n", axes = F, pch = pch, cex.pts = cex.pts, xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab, main = main, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, bty = "n", ...)
    box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
  } else {
    if (is.null(xlabels) & is.null(ylabels)) {
      graphics::plot(fr.exprs, col = adjustcolor(col.pts, alpha.pts), pch = pch, main = main, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, cex = cex.pts, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, bty = "n", ...)
      box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
    } else if (!is.null(xlabels) & is.null(ylabels)) {
      graphics::plot(fr.exprs, xaxt = "n", col = adjustcolor(col.pts, alpha.pts), pch = pch, main = main, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, cex = cex.pts, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, bty = "n", ...)
      axis(1, at = xlabels$at, labels = xlabels$label)
      box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
    } else if (is.null(xlabels) & !is.null(ylabels)) {
      graphics::plot(fr.exprs, yaxt = "n", col = adjustcolor(col.pts, alpha.pts), pch = pch, main = main, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, cex = cex.pts, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, bty = "n", ...)
      axis(2, at = ylabels$at, labels = ylabels$label)
      box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
    } else if (!is.null(xlabels) & !is.null(ylabels)) {
      graphics::plot(fr.exprs, xaxt = "n", yaxt = "n", col = adjustcolor(col.pts, alpha.pts), pch = pch, main = main, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, cex = cex.pts, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, bty = "n", ...)
      axis(1, at = xlabels$at, labels = xlabels$label)
      axis(2, at = ylabels$at, labels = ylabels$label)
      box(which = "plot", lty = border_line_type, lwd = border_line_width, col = border_line_col)
    }
  }

  # Contour Lines
  if (contours != 0) {

    # Calculate 2D kernel density using kde2d from MASS
    z <- MASS::kde2d(fr.exprs[, 1], fr.exprs[, 2], n = 75)

    # Add contour lines to plot
    graphics::contour(z = z$z, x = z$x, y = z$y, add = TRUE, drawlabels = FALSE, nlevels = contours, col = col.contour, lwd = lwd.contour)
  }

  # Add overlays
  if (!is.null(overlay)) {
    mapply(function(overlay, col.overlay, alpha.overlay) {
      points(x = exprs(overlay)[, channels[1]], y = exprs(overlay)[, channels[2]], pch = ".", col = adjustcolor(col.overlay, alpha.overlay), cex = cex.pts)
    }, overlay, col.overlay, alpha.overlay)
  }

  # Add legend
  if (!is.null(overlay) & legend == TRUE) {

    # Legend position x
    legend.x <- par("usr")[2] + 0.025 * par("usr")[2]

    # Legend position y
    legend.y <- mean(par("usr")[c(3, 4)]) + (((par("usr")[4]) / 21) * 0.5 * smp)

    # Legend colours
    if (missing(col)) {
      col.pts <- "blue"
    } else if (is.na(col[1])) {
      col.pts <- "blue"
    }

    # Legend with lines
    if (!missing(col.legend) & missing(fill.legend)) {
      legend(x = legend.x, y = legend.y, legend = text.legend, col = col.legend, xpd = TRUE, bty = "n", x.intersp = 0.5)
    } else if (missing(col.legend) & !missing(fill.legend)) {
      legend(x = legend.x, y = legend.y, legend = text.legend, fill = fill.legend, xpd = TRUE, bty = "n", x.intersp = 0.5)
    } else if (missing(col.legend) & missing(fill.legend)) {
      legend(x = legend.x, y = legend.y, legend = text.legend, fill = c(col.pts, col.overlay), xpd = TRUE, bty = "n", x.intersp = 0.5)
    }
  }

  # Gates
  if (!is.null(gates)) {
    plotGates(gates, channels = channels, col.gate = col.gate, lwd.gate = lwd.gate, lty.gate = lty.gate)
  }

  # Labels
  if (!is.null(gates) & labels == TRUE) {
    if (class(gates) %in% c("rectangleGate", "polygonGate", "ellipsoidGate")) {
      gates <- filters(list(gates))
    } else if (class(gates) == "list") {
      gates <- filters(gates)
    } else if (class(gates) == "filters") {

    }

    # Population names missing - show percantage only
    if (missing(text.labels)) {
      plotLabels(x = fr, channels = channels, alias = NA, gates = gates, format.text = "percent", cex.text = cex.labels, font.text = font.labels, col.text = col.labels, alpha = alpha.labels)
    } else if (!missing(text.labels)) {
      plotLabels(x = fr, channels = channels, alias = text.labels, gates = gates, format.text = format.labels, cex.text = cex.labels, font.text = font.labels, col.text = col.labels, alpha = alpha.labels)
    }
  }

  # Return options to default
  options(scipen = 0)

  # Return plot margins to default
  par(mar = c(5, 4, 4, 2) + 0.1)
})

#' cyto_2d_plot - flowSet Method
#'
#' Visualise 2-D flow cytometry scatterplots with blue-red density colour scale
#' for a flowSet.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param channels names of channels or markers to be used to construct the
#'   plot.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transList object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transList will NOT be applied to the
#'   flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param merge a vector of pData variables tomerge samples into groups, set
#'   to NULL by default to prevent merging. To merge all samples set this
#'   argument to "all".
#' @param overlay a \code{flowFrame}, \code{flowSet}, \code{list of flowFrames},
#'   \code{list of flowSets} or \code{list of flowFrame lists} containing
#'   populations to be overlayed onto the plot(s).
#' @param display  numeric indicating the number of events to plot, set to all
#'   events by default. Reducing the sample size can significantly improve
#'   plotting speed on less powerful machines.
#' @param layout a vector of the length 2 indicating the dimensions of the grid
#'   for plotting \code{c(#rows, #columns)}.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of x axis (e.g. c(0,5)).
#' @param title title for the plot, set to the name of the sample by default.
#' @param ... additional arguments passed to \code{\link{plotCyto2d,flowFrame-method}}.
#'
#' @examples
#' \dontrun{
#' fs <- Activation
#' cyto_2d_plot(fs, channel = c("FSC-A", "SSC-A"), overlay = fs[[2]], col = c(NA, "purple"))
#' cyto_2d_plot(fs, channel = c("FSC-A", "SSC-A"), overlay = fs[[2]], col = c("black", "red"))
#' }
#' 
#' @importFrom flowCore exprs parameters fsApply
#' @importFrom flowWorkspace pData sampleNames
#' @importFrom graphics plot axis title abline polygon contour legend points par
#' @importFrom grDevices densCols colorRampPalette n2mfrow
#' @importFrom methods as
#'
#' @seealso \code{\link{cyto_2d_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_plot,flowSet-method}}
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
setMethod(cyto_2d_plot, signature = "flowSet", definition = function(x, channels, axes_trans = NULL, merge = NULL, overlay = NULL, display = NULL, layout = NULL, popup = FALSE, limits = "machine", xlim = NULL, ylim = NULL, title, ...) {

  # Prevent scientific notation
  options(scipen = 999)

  # Assign x to fs
  fs <- x
  fs.channels <- BiocGenerics::colnames(fs)

  # Sample names
  fsnms <- flowWorkspace::sampleNames(fs)

  # Check channels
  channels <- checkChannels(fs, channels = channels, plot = TRUE)

  # transList
  if (!is.null(transList)) {
    transList <- checkTransList(transList, inverse = FALSE)
  }

  # X axis limits
  if (is.null(xlim)) {
    xlim <- suppressWarnings(.getAxesLimits(x = fs, channels = channels, overlay = overlay, limits = limits)[[1]])
  }

  # Y axis limits
  if (is.null(ylim)) {
    ylim <- suppressWarnings(.getAxesLimits(x = fs, channels = channels, overlay = overlay, limits = limits)[[2]])
  }

  # MergeBy?
  if (!is.null(mergeBy)) {

    # Return a list of merged flowFrames
    fr.lst <- .mergeBy(x = fs, mergeBy = mergeBy)

    if (missing(main) & !mergeBy == "all") {
      main <- names(fr.lst)
    } else if (missing(main) & mergeBy == "all") {
      main <- "Combined Events"
    }

    # overlay
    if (!is.null(overlay)) {
      overlay <- checkOverlay(x = fs, overlay = overlay, subSample = subSample)

      # list of flowFrame lists to overlay (1 per group)
      overlay <- .mergeOverlay(x = fs, overlay = overlay, mergeBy = mergeBy, subSample = subSample)
    }

    # Plot layout
    mfrow <- .setPlotLayout(x = fr.lst, mfrow = mfrow)

    # Plots
    if (is.null(overlay)) {
      mapply(function(fr, main) {
        plotCyto2d(x = fr, channels = channels, subSample = subSample, transList = transList, main = main, xlim = xlim, ylim = ylim, popup = popup, mfrow = FALSE, ...)
      }, fr.lst, main)
    } else {
      mapply(function(fr, main, overlay) {
        plotCyto2d(x = fr, channels = channels, subSample = subSample, transList = transList, overlay = overlay, main = main, xlim = xlim, ylim = ylim, popup = popup, mfrow = FALSE, ...)
      }, fr.lst, main, overlay)
    }
  } else if (is.null(mergeBy)) {

    # Number of samples
    smp <- length(fs)

    # Convert fs to list of flowFrames
    fr.lst <- lapply(seq(1, length(fs), 1), function(x) fs[[x]])
    names(fr.lst) <- fsnms

    # subSample flowFrames
    if (!missing(subSample)) {
      fr.lst <- lapply(fr.lst, function(x) {
        sampleFrame(x, subSample)
      })
    }

    # Overlays
    if (!is.null(overlay)) {
      overlay <- checkOverlay(x = fs, overlay = overlay, subSample = subSample)
    }

    # Pop-up
    if (popup == TRUE) {
      checkOSGD()
    }

    # Plot layout
    mfrow <- .setPlotLayout(x = fs, mfrow = mfrow)

    # Number of plots in window
    np <- mfrow[1] * mfrow[2]

    # Titles
    if (missing(main)) {
      main <- sampleNames(fs)
    }

    # Plot
    if (!is.null(overlay)) {
      cnt <- 0
      mapply(function(fr, o, main) {
        cnt <<- cnt + 1

        plotCyto2d(x = fr, channels = channels, transList = transList, overlay = o, main = main, xlim = xlim, ylim = ylim, ...)

        if (popup == TRUE & cnt %% np == 0 & length(fr.lst) > cnt) {
          checkOSGD()
        }
      }, fr.lst, overlay, main)
    } else {
      cnt <- 0
      mapply(function(fr, main) {
        cnt <<- cnt + 1

        plotCyto2d(x = fr, channels = channels, transList = transList, main = main, xlim = xlim, ylim = ylim, ...)

        if (popup == TRUE & cnt %% np == 0 & length(fr.lst) > cnt) {
          checkOSGD()
        }
      }, fr.lst, main)
    }
  }

  # Return mfrow to default
  if (mfrow[1] != FALSE) {
    par(mfrow = c(1, 1))
  }

  # Return options to default
  options(scipen = 0)
})
