#' plotCyto1d
#'
#' Visualise 1-D flow cytometry density distributions.
#'
#' For a complete list of customisation arguments see
#' \code{\link{plotCyto1d,flowFrame-method}}.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}} or
#'   \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param ... additional method-specific arguments for plotCyto1d.
#'
#' @seealso \code{\link{plotCyto1d,flowFrame-method}}
#' @seealso \code{\link{plotCyto1d,flowSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
setGeneric(name = "plotCyto1d",
           def = function(x, ...){standardGeneric("plotCyto1d")}
)

#' plotCyto1d - flowFrame Method
#'
#' Visualise 1-D flow cytometry density distributions for a flowFrame.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param channel name of the channel or marker to be used to construct the
#'   plot.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transList object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transList will NOT be applied to the
#'   flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param overlay a \code{flowFrame}, \code{flowSet} or list of
#'   \code{flowFrames} to be overlayed onto the plot.
#' @param gates gate object(s) to be added to plot.  For \code{plotCyto1d} only
#'   gate objects of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}} generated by
#'   drawInterval are supported. Multple gates can be supplied either as a
#'   \code{list} or \code{\link[flowCore:filters-class]{filters}} list.
#' @param modal logical indicating whether density should be normalised to mode
#'   and presented as a percentage. Set to \code{TRUE} by default.
#' @param offset numeric [0,1] indicating the degree of offset for overlayed
#'   populations, set to 0.5 by default.
#' @param adjust smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of x axis (e.g. c(0,5)).
#' @param main title to use for the plot, set to the name of the sample by
#'   default.
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param fill colour(s) used to fill polygons.
#' @param alpha numeric [0,1] used to control fill transparency, set to 1 by
#'   default to remove transparency.
#' @param col colour(s) for border line, set to "black" by default.
#' @param lty line type(s) to use for border(s), set to solid lines by default.
#' @param lwd line width for border.
#' @param cex.axis character expansion for axis text.
#' @param col.axis colour of axis text.
#' @param cex.lab character expansion for axis labels.
#' @param col.lab colour of axis labels.
#' @param cex.main character expansion for plot title.
#' @param col.main colour for plot title.
#' @param legend logical indicating whether a legend should be included for
#'   plots including overlays, set to FALSE by default.
#' @param text.legend vector of labels to use for the legend.
#' @param col.legend vector of line colours to use for legend.
#' @param fill.legend vector of fill colours to use for legend.
#' @param cex.legend character expansion for legend text, set to 1 by default.
#' @param col.gate indicates the colour of the gate to be constructed, set to
#'   \code{"red"} by default.
#' @param lwd.gate numeric to adjust line thickness of gates, set to \code{2.5}
#'   by default.
#' @param lty.gate integer [0,6] which controls the line type, set to \code{1}
#'   to draw solid lines by default.
#' @param labels logical indicating whether gated populations should be
#'   labelled. If the names of the populations are supplied as the text.labels
#'   argument, the population name and frequency will be included in the labels,
#'   otherwise only the population frequencies will be included in the labels.
#' @param text.labels vector of population names to use in labels.
#' @param format.labels indicates the type of text to include in the label, can
#'   be either \code{"alias"}, \code{"percent"}, \code{"count"},
#'   \code{c("alias","percent")} or \code{c("alias","count")}. Set to
#'   \code{c("alias","percent")} by default.
#' @param cex.labels character expansion for label text, set to 0.8 by default.
#' @param font.labels numeric indicating the font to use for labels, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param col.labels colour of text used in labels, set to \code{"black"} by
#'   default.
#' @param alpha.labels numeric controlling backgropund fill transparency of
#'   labels, set to 0.6 by default to introduce some transparency.
#' @param ... additional arguments passed to \code{\link[graphics:plot]{plot}}.
#'
#' @examples
#' \dontrun{
#'   fs <- Activation
#'   plotCyto1d(fs[[1]], channel = "FSC-A", overlay = fs[[2]], fill = c("red","blue"))
#' }
#'
#' @importFrom flowCore exprs parameters
#' @importFrom flowWorkspace pData
#' @importFrom graphics plot axis title abline polygon legend par
#' @importFrom grDevices adjustcolor
#' @importFrom stats density
#'
#' @seealso \code{\link{plotCyto1d,flowSet-method}}
#' @seealso \code{\link{plotCyto,flowFrame-method}}
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export

setMethod(plotCyto1d, signature = "flowFrame", definition = function(x, channel, transList = NULL, overlay = NULL, gates = NULL, modal = TRUE, offset = 0.5, adjust = 1.5, popup = FALSE,
                                                                     limits = "machine", xlim = NULL, ylim, main, xlab, ylab, fill, alpha = 1, col = "black", lty = 1, lwd = 1, cex.axis = 1, 
                                                                     col.axis = "black", cex.lab = 1.1, col.lab = "black", cex.main = 1.1, col.main = "black", legend = FALSE,
                                                                     text.legend, col.legend, fill.legend, cex.legend = 1, col.gate = "red", lwd.gate = 2.5, lty.gate = 1,
                                                                     labels = TRUE, format.labels = c("alias","percent"), text.labels, 
                                                                     cex.labels = 0.8, font.labels = 2, col.labels = "black", alpha.labels = 0.6, ...){
  
  # Assign x to fr
  fr <- x
  fr.channels <- BiocGenerics::colnames(fr)
    
  # Check channel
  channel <- checkChannels(fr, channels = channel, plot = TRUE)
  
  # Prevent scientific notation
  options(scipen = 999)
  
  # Axes limits
  if(is.null(xlim)){
    
    if(limits == "data"){
      
      xlim <- suppressWarnings(axesLimits(x = fr, channels = channel, overlay = overlay, upper = TRUE)[[1]])
      
    }else if(limits == "machine"){
      
      xlim <- suppressWarnings(axesLimits(x = fr, channels = channel, overlay = overlay, upper = FALSE)[[1]])
      
    }
    
  }
  
  # Get Axis Breaks and Labels from transList if supplied
  if(!is.null(transList)){
    
    transList <- checkTransList(transList, inverse = FALSE)
    axs <- axisLabels(fr, channel = channel, transList = transList)
    axs <- list(axs)
    names(axs) <- channel
    xlabels <- axs[[1]]
    
  }else{
    
    axs <- list(NULL)
    xlabels <- NULL
    
  } 
  
  # Check overlay -> list of fowFrames
  if(!is.null(overlay)){
    
    overlay <- checkOverlay(x = fr, overlay = overlay)
  }
  
  # Merge fr with overlay if supplied - named list of fr & overlay
  if(!is.null(overlay)){
    
    frs <- c(list(fr), overlay)
    names(frs) <- as.vector(sapply(frs, function(fr) fr@description$GUID))
    modal <- TRUE
    
  }else{
    
    frs <- list(fr)
    names(frs) <- fr@description$GUID
    modal <- modal
    
  }
  
  # Extract information
  fr.data <- flowWorkspace::pData(parameters(fr))
  fr.channels <- BiocGenerics::colnames(fr)
  
  # Extract data from frs and calculate kernel density
  adjust <- adjust
  frs.dens <- lapply(frs, function(fr){
    
    fr.exprs <- flowCore::exprs(fr)[,channel]
    fr.dens <- density(fr.exprs, adjust = adjust)
    
    if(modal == TRUE){
      
      fr.dens$y <- (fr.dens$y / max(fr.dens$y))*100
      
    }
    
    return(fr.dens)
    
  })
  
  # number of overlays
  ovn <- length(frs.dens) - 1
  
  # Y axis labels
  if(ovn == 0){
    
    ylabels <- TRUE
    
  }else if(ovn != 0 & offset == 0){
    
    ylabels <- TRUE
    
  }else if(ovn != 0 & offset != 0){
    
    ylabels <- FALSE
    
  }
  
  # Adjust values if offset != 0
  if(offset != 0){

    # Calculate offset for each overlay
    ofst <- seq(0, ovn*offset*100, offset*100)
    
    # Offset overlays
    frs.dens<- mapply(function(fr.dens, ofst){
      
      fr.dens$y <- fr.dens$y + ofst
      
      return(fr.dens)
      
    }, frs.dens, ofst, SIMPLIFY = FALSE)
  
  }else if(offset == 0){
    
    ofst <- 0
    
  }
  
  # Title
  if(missing(main)){
    
    main <- fr@description$GUID
    
  }else if(is.null(main)){
    
    # Remove excess space above plot
    par(mar = c(5, 4, 2, 2) + 0.1)
    
  }
  
  # Axes Labels
  if(missing(ylab) & !modal){
    
    ylab <- "Density"
    
  }else if(missing(ylab) & modal){
    
    ylab <- "Density Normalised to Mode (%)"
    
  }
  
  if(missing(xlab)){
    
    if(!is.na(fr.data$desc[which(fr.channels == channel)])){
      
      xlab <- paste(fr.data$desc[which(fr.channels == channel)], channel, sep = " ")
      
    }else if(is.na(fr.data$desc[which(fr.channels == channel)])){
      
      xlab <- paste(channel, sep = " ")
      
    }
    
  }
  
  # Y Axis Limits
  if(missing(ylim)){
    
    if(is.null(overlay)){
      
      if(modal == FALSE){
        
        ylim <-  range(frs.dens[[1]]$y)
        
      }else if(modal == TRUE){
        
        ylim <- c(0,100)
        
      }
      
    }else if(!is.null(overlay)){
      
      # No offset with overlay y limits c(0,100)
      if(offset == 0){
        
        ylim <- c(0,100)
        
      }else if(offset != 0){
        
        # Overlays with offset
        ylim = c(0, (100 + ovn*offset*100))
        
      }
      
    }
    
  }
  
  # Overlay colours
  cols <- colorRampPalette(c("grey","bisque4","brown1","red", "darkred","chocolate","orange", "yellow", "yellowgreen", "green", "aquamarine","cyan", "cornflowerblue","blue", "blueviolet","purple","magenta","deeppink"))
  
  if(missing(fill)){
    
    fill <- cols(length(frs.dens))
    
  }else if(length(fill) < length(frs.dens)){
    
    fill <- c(fill, cols((length(frs.dens) - length(fill))))
    
  }else if(length(fill) > length(frs.dens)){
    
    fill <- fill[length(frs.dens)]
    
  }
  
  # Border colours
  if(length(col) == 1){
    
    col <- rep(col, length(frs.dens))
    
  }else if(length(col) < length(frs.dens)){
    
    col <- c(col, cols((length(frs.dens) - length(col))))
    
  }else if( length(col) > length(frs.dens)){
    
    col <- col[length(frs.dens)]
    
  }
  
  # Border thickness
  if(length(lwd) == 1){
    
    lwd <- rep(lwd, length(frs.dens))
    
  }else if(length(lwd) < length(frs.dens)){
    
    lwd <- c(lwd, rep(1, (length(frs.dens) - length(lwd))))
    
  }else if(length(lwd) > length(frs.dens)){
    
    lwd <- lwd[length(frs.dens)]
    
  }
  
  # Border line type
  if(length(lty) == 1){
    
    lty <- rep(lty, length(frs.dens))
    
  }else if(length(lty) < length(frs.dens)){
    
    lty <- c(lty, rep(1, (length(frs.dens) - length(lty))))
    
  }else if(length(lty) > length(frs.dens)){
    
    lty <- lty[length(frs.dens)]
    
  }
  
  # Alpha
  if(length(alpha) == 1){
    
    alpha <- rep(alpha, length(frs.dens))
    
  }else if(length(alpha) < length(frs.dens)){
    
    alpha <- c(alpha, rep(1, (length(frs.dens) - length(alpha))))
    
  }else if(length(alpha) > length(frs.dens)){
    
    alpha <- alpha[length(frs.dens)]
    
  }
  
  # Pop-up
  if(popup == TRUE){
    
    checkOSGD()
    
  }
  
  # plot margins
  if(!is.null(overlay) & legend == TRUE){
    
    if(missing(text.legend)){
      
      mrgn <- 7 + max(nchar(names(frs)))*0.32
      
    }else{
      
      mrgn <- 7 + max(nchar(text.legend))*0.32
      
    }
    
    par(mar = c(5, 5, 4, mrgn) + 0.1)
    
    if(is.null(main)){
      
      par(mar = c(5, 5, 2, mrgn) + 0.1)

    }
    
  }else{
    
    par(mar = c(5, 5, 4, 2) + 0.1)
    
    if(is.null(main)){
      
      par(mar = c(5, 5, 2, 2) + 0.1)
      
    }
    
  }

  # Set up empty plot
  if(is.null(xlabels) & ylabels == FALSE){
    
    graphics::plot(1, type = "n", yaxt = "n", xlim = xlim, ylim = ylim, axes = TRUE, cex.axis = cex.axis, col.axis = col.axis, ann = FALSE, ...)
    abline(h = c(0, ofst), col = col[length(frs.dens):1])
    title(main = main, cex.main = cex.main, col.main = col.main)
    title(xlab = xlab, col.lab = col.lab, cex.lab = cex.lab)
    title(ylab = ylab, mgp = c(2,0,0), col.lab = col.lab, cex.lab = cex.lab)

  }else if(is.null(xlabels) & ylabels == TRUE){
    
    graphics::plot(1, type = "n", xlim = xlim, ylim = ylim, axes = TRUE, cex.axis = cex.axis, col.axis = col.axis, ann = FALSE, las = 1, ...)
    abline(h = c(0, ofst), col = col[length(frs.dens):1])
    title(main = main, cex.main = cex.main, col.main = col.main)
    title(xlab = xlab, col.lab = col.lab, cex.lab = cex.lab)
    title(ylab = ylab, mgp = c(3,0,0), col.lab = col.lab, cex.lab = cex.lab)
    
  }else if(!is.null(xlabels) & ylabels == FALSE){
    
    graphics::plot(1, type = "n", yaxt = "n", xaxt = "n", xlim = xlim, ylim = ylim, axes = TRUE, cex.axis = cex.axis, col.axis = col.axis, ann = FALSE, ...)
    axis(1, at = xlabels$at, labels = xlabels$label)
    abline(h = c(0, ofst), col = col[length(frs.dens):1])
    title(main = main, cex.main = cex.main, col.main = col.main)
    title(xlab = xlab, col.lab = col.lab, cex.lab = cex.lab)
    title(ylab = ylab, mgp = c(2,0,0), col.lab = col.lab, cex.lab = cex.lab)
    
  }else if(!is.null(xlabels) & ylabels == TRUE){
    
    graphics::plot(1, type = "n", xaxt = "n", xlim = xlim, ylim = ylim, axes = TRUE, xlab = xlab, ylab = ylab, cex.axis = cex.axis, col.axis = col.axis, ann = FALSE, las = 1, ...)
    axis(1, at = xlabels$at, labels = xlabels$label)
    abline(h = c(0, ofst), col = col[length(frs.dens):1])
    title(main = main, cex.main = cex.main, col.main = col.main)
    title(xlab = xlab, col.lab = col.lab, cex.lab = cex.lab)
    title(ylab = ylab, mgp = c(3,0,0), col.lab = col.lab, cex.lab = cex.lab)
    
  }
  
  # Add density distributions - reverse plot order and colours
  if(!is.null(overlay) & offset == 0){
    
    mapply(function(fr.dens, fill, col, lwd, lty, alpha){
      
      polygon(fr.dens, col = adjustcolor(fill, alpha), border = col, lwd = lwd, lty = lty)
      
    }, frs.dens, fill, col, lwd, lty, alpha)
    
    
  }else{
    
    mapply(function(fr.dens, fill, col, lwd, lty, alpha){
    
      polygon(fr.dens, col = adjustcolor(fill, alpha), border = col, lwd = lwd, lty = lty)
    
    }, frs.dens[length(frs.dens):1], fill[length(frs.dens):1], col[length(frs.dens):1], lwd[length(frs.dens):1], lty[length(frs.dens):1], alpha[length(frs.dens):1])
    
  }
  
  # Add legend
  if(!is.null(overlay) & legend == TRUE){
    
    # Legend position x
    legend.x <- par("usr")[2] + 0.025*par("usr")[2]
    
    # Legend position y
    legend.y <- mean(par("usr")[c(3,4)]) + (((par("usr")[4])/21)*0.5*length(frs.dens))
    
    # Legend labels
    if(missing(text.legend)){
      
      text.legend <- names(frs)[length(frs):1]
        
    }else{
      
      text.legend <- text.legend[length(text.legend):1]
      
    }
    
    # Legend with lines
    if(!missing(col.legend) & missing(fill.legend)){
      
      legend(x = legend.x, y = legend.y, legend = text.legend, col = col.legend, lty = lty, lwd = lwd, xpd = TRUE, bty = "n", x.intersp = 0.5)
      
    }else if(missing(col.legend) & !missing(fill.legend)){
    
      legend(x = legend.x, y = legend.y, legend = text.legend, fill = fill.legend, xpd = TRUE, bty = "n", x.intersp = 0.5)
    
    }else if(missing(col.legend) & missing(fill.legend)){
      
      legend(x = legend.x, y = legend.y, legend = text.legend, fill = fill[length(frs):1], xpd = TRUE, bty = "n", x.intersp = 0.5)
      
    }
    
  }
  
  # Gates
  if(!is.null(gates)){
    
    plotGates(gates, channels = channel, col.gate = col.gate, lwd.gate = lwd.gate, lty.gate = lty.gate)
    
  }
  
  # Labels
  if(!is.null(gates) & labels == TRUE){
    
    # Population names missing - show percantage only
    if(missing(text.labels)){
    
      plotLabels(x = fr, channels = channel, alias = NA, gates = gates, format.text = format.labels, cex.text = cex.labels, font.text = font.labels, col.text = col.labels, alpha = alpha.labels)
    
    }else if(!missing(text.labels)){
      
      plotLabels(x = fr, channels = channel, alias = text.labels, gates = gates, format.text = format.labels, cex.text = cex.labels, font.text = font.labels, col.text = col.labels, alpha = alpha.labels)
      
    }
    
  }

  # Return options to default
  options(scipen = 0)
  
  # Return plot margins to default
  par(mar = c(5, 4, 4, 2) + 0.1)
  
})

#' plotCyto1d - flowSet Method
#'
#' Visualise 1-D flow cytometry density distributions for a flowSet.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param channel name of the channel or marker to be used to construct the
#'   plot.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transList object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transList will NOT be applied to the
#'   flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param merge logical indicating whether the flowFrames should be merged prior
#'   to plotting to yield a single plot, set to FALSE by default.
#' @param overlay a \code{flowFrame}, \code{flowSet}, \code{list of flowFrames},
#'   \code{list of flowSets} or \code{list of flowFrame lists} containing
#'   populations to be overlaid onto the plot(s).
#' @param stack vector of length 2 indicating offset for samples and number of
#'   samples per plot. Set to \code{c(0,1)} to plot each sample in a separate
#'   panel.
#' @param offset numeric [0,1] indicating the degree of offset for overlayed
#'   populations, set to 0.5 by default.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param mfrow a vector of the length 2 indicating the dimensions of the grid
#'   for plotting \code{c(#rows, #columns)}.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param main vector of titles to use for each plot, set to name of the sample
#'   by default.
#' @param ... additional arguments passed to
#'   \code{\link{plotCyto1d,flowFrame-method}}.
#'
#' @examples
#' \dontrun{
#'   fs <- Activation
#'   plotCyto1d(fs, channel = "FSC-A", legend = TRUE)
#' }
#'
#' @seealso \code{\link{plotCyto1d,flowFrame-method}}
#' @seealso \code{\link{plotCyto,flowSet-method}}
#'
#' @importFrom flowCore exprs parameters fsApply
#' @importFrom flowWorkspace pData sampleNames
#' @importFrom graphics plot axis title abline polygon legend
#' @importFrom grDevices n2mfrow
#' @importFrom graphics par
#' @importFrom methods as
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
setMethod(plotCyto1d, signature = "flowSet", definition = function(x, channel, transList = NULL, merge = FALSE, overlay = NULL, stack = c(0,1), offset = 0.5, limits = "machine", xlim = NULL, mfrow, popup = FALSE, main,  ...){
  
  # Assign x to fs
  fs <- x
  fs.channels <- BiocGenerics::colnames(fs)
  
  # Check channel
  channel <- checkChannels(x = fs, channels = channel, plot = TRUE)
  
  # Prevent scientific notation
  options(scipen = 999)

  # Axes limits
  if(is.null(xlim)){
    
    if(limits == "data"){
      
      xlim <- suppressWarnings(axesLimits(x = fs, channels = channel, overlay = overlay, upper = TRUE)[[1]])
      
    }else if(limits == "machine"){
      
      xlim <- suppressWarnings(axesLimits(x = fs, channels = channel, overlay = overlay, upper = FALSE)[[1]])
      
    }
    
  }
  
  # Merge?
  if(merge == TRUE){
    
    fr <- as(fs, "flowFrame")
    
    if(is.na(match("Original", BiocGenerics::colnames(fr))) == FALSE){
      
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      
    }
    
    if(missing(main)){
      
      main <- "Combined Events"
      
    }
    
    # Check overlay
    if(!is.null(overlay)){
      
      overlay <- checkOverlay(x = fr, overlay = overlay)
      
    }
    
    # mfrow
    if(missing(mfrow)){
      
      mfrow <-c(1,1)
      
    }
    
    # Plot
    plotCyto1d(x = fr, channel = channel, transList = transList, overlay = overlay, offset = offset, main = main, xlim = xlim, popup = popup, mfrow = mfrow, ...)
    
  }else if(merge == FALSE){

  # Stacking
  if(stack[1] != 0){
    
    if(length(stack) == 1){
      
      stack[2] <- length(fs)
      
    }else if(is.na(stack[2])){
      
      stack[2] <- length(fs)
      
    }
    
  }

  # Number of samples
  smp <- length(fs)
  
  # Convert fs to list of flowFrames
  fs.lst <- lapply(seq(1,length(fs),1), function(x) fs[[x]])
  
  # No stacking - each in new plot
  if(stack[1] == 0){
    
    # Overlays - list containing flowFrame lists
    if(!is.null(overlay)){
     
      overlay <- checkOverlay(x = fs, overlay = overlay)
     
    }
    
    # Pop-up window
    if(popup == TRUE){
      
      checkOSGD()
      
    }
    
    # Grid layout
    if(missing(mfrow)){
      
      mfrow <- c(n2mfrow(smp)[2], n2mfrow(smp)[1])
      par(mfrow = mfrow)
      
    }else if(!missing(mfrow)){
      
      if(mfrow[1] == FALSE){
        
        # Do nothing
        
      }else{
        
        par(mfrow = mfrow)
        
      }
      
    }

    # Plot space
    np <- mfrow[1] * mfrow[2]
    
    # Titles
    if(missing(main)){
      
      main <- sampleNames(fs)
      
    }
    
    # Plot
    if(!is.null(overlay)){
      
      cnt <- 0
      mapply(function(fr, o, main){
        
        cnt <<- cnt + 1
      
        plotCyto1d(x = fr, channel = channel, transList = transList, overlay = o, offset = offset, main = main, xlim = xlim, ...)
        
        if(popup == TRUE & cnt %% np == 0 & length(fs.lst) > cnt){
          
          checkOSGD()
          
        } 
        
      }, fs.lst, overlay, main)
      
    }else{
      
      cnt <- 0
      mapply(function(fr, main){

        cnt <<- cnt + 1
        plotCyto1d(x = fr, channel = channel, transList = transList, offset = offset, main = main, xlim = xlim, ...)
        
        if(popup == TRUE & cnt %% np == 0 & length(fs.lst) > cnt){
          
          checkOSGD()
          
        } 
        
      }, fs.lst, main)
      
    }
    
  # Stacking - set offset to zero
  }else if(stack[1] != 0){
    
    # Stacked overlays not yet supported
    if(!is.null(overlay)){
      
      message("Overlays are not yet supported for stacked samples. Overlay and offset arguments will be ignored during plotting.")
    
    }
    
    # split up samples based on stack[2]
    nm <- ceiling(length(fs.lst)/stack[2])
    fs.lsts <- lapply(seq(stack[2],nm*stack[2],stack[2]), function(x){
      
      i <- x-stack[2]+1
      fs.lst[i:x]
      
    })
    
    # mfrow length(fs)/stack
    if(missing(mfrow)){
      
      smp <- ceiling(length(fs)/stack[2])
      mfrow <- c(n2mfrow(smp)[2], n2mfrow(smp)[1])
      par(mfrow = mfrow)
      
    }else if(!missing(mfrow)){
      
      if(mfrow[1] == FALSE){
        
        # Do nothing
        
      }else{
        
        par(mfrow = mfrow)
        
      }
      
    }

    
    # Main
    if(missing(main)){
      
      main <- NULL
      
    }
    
    # Pass first frame to .plotCyto1d with others as list of frames - popup?
    lapply(fs.lsts, function(fs.lst){
      
      fr.lst <- fs.lst[2:length(fs.lst)]

      plotCyto1d(x = fs.lst[[1]], channel = channel, transList = transList, overlay = fr.lst, offset = stack[1], main = main, xlim = xlim, ...)
      
    })
    
  }
  
  }
  
  # Return mfrow to default
  if(!missing(mfrow) & mfrow[1] != FALSE){
    
    par(mfrow = c(1,1))
    
  }
  
  # Return options to default
  options(scipen = 0)
  
})

#' plotCyto2d
#' 
#' Visualise 2-D flow cytometry scatterplots with blue-red density colour scale.
#' 
#' For a complete list of customisation arguments see
#' \code{\link{plotCyto2d,flowFrame-method}}.
#' 
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}} or
#'   \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param ... additional method-specific arguments for plotCyto2d.
#' 
#' @seealso \code{\link{plotCyto2d,flowFrame-method}}
#' @seealso \code{\link{plotCyto2d,flowSet-method}}
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#' 
#' @export
setGeneric(name = "plotCyto2d",
           def = function(x, ...){standardGeneric("plotCyto2d")}
)

#' plotCyto2d - flowFrame Method
#'
#' Visualise 2-D flow cytometry scatterplots with blue-red density colour scale
#' for a flowFrame.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param channels name of the channels or markers to be used to construct the
#'   plot.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transList object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transList will NOT be applied to the
#'   flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param overlay a \code{flowFrame} object to be overlayed onto the plot.
#' @param contours numeric indicating the number of levels to use for contour
#'   lines, set to 0 by default to turn off contour lines.
#' @param gates gate object(s) to be added to plot. Gates can be of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}},
#'   \code{\link[flowCore:polygonGate-class]{polygonGate}} or
#'   \code{\link[flowCore:ellipsoidGate-class]{ellipsoidGate}}. Multiple gates of
#'   mixed classes can also be supplied in \code{list} or
#'   \code{\link[flowCore:filters-class]{filters}} objects.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param subSample  numeric indicating the number of events to plot, set to all
#'   events by default. Reducing the sample size can significantly increase
#'   plotting speed on less powerful machines.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of x axis (e.g. c(0,5)).
#' @param main title to use for the plot, set to the name of the sample by
#'   default.
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param pch point character to use for points, set to "." by default to
#'   maximise plotting speed.
#' @param cex.pts numeric specifying the degree of character expansion for
#'   points, set to 2 by default.
#' @param col colours to use for points, set to NA by default to blue-red
#'   density colour scale.
#' @param alpha numeric [0,1] used to control col transparency, set to 1 by
#'   default to remove transparency.
#' @param col.contour colour to use for contour lines, set to "black" by
#'   default.
#' @param lwd.contour line width for contour lines, set to 2 by default.
#' @param cex.axis character expansion for axis text.
#' @param col.axis colour of axis text.
#' @param cex.lab character expansion for axis labels.
#' @param col.lab colour of axis labels.
#' @param cex.main character expansion for plot title.
#' @param col.main colour for plot title.
#' @param legend logical indicating whether a legend should be included for
#'   plots including overlays, set to FALSE by default.
#' @param text.legend vector of labels to use for the legend.
#' @param col.legend vector of line colours to use for legend.
#' @param fill.legend vector of fill colours to use for legend.
#' @param cex.legend character expansion for legend text, set to 1 by default.
#' @param col.gate indicates the colour of the gate to be constructed, set to
#'   \code{"red"} by default.
#' @param lwd.gate numeric to adjust line thickness of gates, set to \code{2.5}
#'   by default.
#' @param lty.gate integer [0,6] which controls the line type, set to \code{1}
#'   to draw solid lines by default.
#' @param labels logical indicating whether gated populations should be
#'   labelled. If the names of the populations are supplied as the text.labels
#'   argument, the population name and frequency will be included in the labels,
#'   otherwise only the population frequencies will be included in the labels.
#' @param text.labels vector of population names to use in labels.
#' @param format.labels indicates the type of text to include in the label, can
#'   be either \code{"alias"}, \code{"percent"}, \code{"count"},
#'   \code{c("alias","percent")} or \code{c("alias","count")}. Set to
#'   \code{c("alias","percent")} by default.
#' @param cex.labels character expansion for label text, set to 0.8 by default.
#' @param font.labels numeric indicating the font to use for labels, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param col.labels colour of text used in labels, set to \code{"black"} by
#'   default.
#' @param alpha.labels numeric controlling backgropund fill transparency of
#'   labels, set to 0.6 by default to introduce some transparency.
#' @param ... additional arguments passed to \code{\link[graphics:plot]{plot}}.
#'
#' @examples
#' \dontrun{
#'   fs <- Activation
#'   plotCyto2d(fs[[1]], channel = c("FSC-A","SSC-A"), overlay = fs[[2]], col = c(NA,"purple"))
#'   plotCyto2d(fs[[1]], channel = c("FSC-A","SSC-A"), overlay = fs[[2]], col = c("black","red"))
#'
#' }
#'
#' @importFrom flowCore exprs parameters fsApply
#' @importFrom flowWorkspace pData
#' @importFrom MASS kde2d
#' @importFrom graphics plot axis title abline polygon contour legend points par
#' @importFrom grDevices densCols colorRampPalette adjustcolor
#'
#' @seealso \code{\link{plotCyto2d,flowSet-method}}
#' @seealso \code{\link{plotCyto,flowFrame-method}}
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
setMethod(plotCyto2d, signature = "flowFrame", definition = function(x, channels, transList = NULL, overlay = NULL, contours = 0, gates = NULL, popup = FALSE, subSample = NULL, limits = "machine", xlim = NULL, ylim = NULL,
                                                                     main, xlab, ylab, pch = ".", cex.pts = 2, col, alpha = 1, col.contour = "black", lwd.contour = 1, 
                                                                     cex.axis = 1, col.axis = "black", cex.lab = 1.1, col.lab = "black", cex.main = 1.1,
                                                                     col.main = "black", legend = FALSE, text.legend, col.legend, fill.legend, cex.legend = 1, 
                                                                     col.gate = "red", lwd.gate = 2.5, lty.gate = 1, labels = TRUE, text.labels, format.labels = c("alias","percent"), cex.labels = 0.8, font.labels = 2, 
                                                                     col.labels = "black", alpha.labels = 0.6,...){
  
  # Assign x to fr
  fr <- x
  fr.channels <- BiocGenerics::colnames(fr)
    
  # Check channels
  channels <- checkChannels(fr, channels = channels, plot = TRUE)
  
  # Prevent scientific notation
  options(scipen = 999)
  
  # X axis limits
  if(is.null(xlim)){
    
    if(limits == "data"){
      
      xlim <- suppressWarnings(axesLimits(x = fr, channels = channels, overlay = overlay, upper = TRUE)[[1]])
      
    }else if(limits == "machine"){
      
      xlim <- suppressWarnings(axesLimits(x = fr, channels = channels, overlay = overlay, upper = FALSE)[[1]])
      
    }
    
  }
  
  # Y axis limits
  if(is.null(ylim)){
    
    if(limits == "data"){
      
      ylim <- suppressWarnings(axesLimits(x = fr, channels = channels, overlay = overlay, upper = TRUE)[[2]])
      
    }else if(limits == "machine"){
      
      ylim <- suppressWarnings(axesLimits(x = fr, channels = channels, overlay = overlay, upper = FALSE)[[2]])
      
    }
    
  }
  
  # subSample
  if(!is.null(subSample)){
    
    fr <- sampleFrame(fr, subSample)
    
  }
  
  # Get Axis Breaks and Labels from trans
  if(!is.null(transList)){
    
    transList <- checkTransList(transList, inverse = FALSE)
    axs <- lapply(channels, function(channel) {axisLabels(fr, channel = channel, transList = transList)})
    names(axs) <- channels
    xlabels <- axs[[1]]
    ylabels <- axs[[2]]
    
  }else{
    
    axs <- list(NULL, NULL)
    xlabels <- axs[[1]]
    ylabels <- axs[[2]]
    
  }  
  
  # overlay
  if(!is.null(overlay)){
    
    overlay <- checkOverlay(x = fr, overlay = overlay, subSample = subSample)
    
  }
  
  # Number of samples
  if(!is.null(overlay)){
    
    smp <- 1 + length(overlay)
    
  }else{
    
    smp <- 1
    
  }
  
  # Extract data for plotting
  fr.exprs <- flowCore::exprs(fr)[, channels]
  
  # Extract pData and Channels
  fr.data <- flowWorkspace::pData(flowCore::parameters(fr))
  
  # Point colour - 2D colour scale
  if(missing(col)){
    
    cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
    col.pts <- densCols(fr.exprs[,channels], colramp = cols)
    
    if(!is.null(overlay)){
      
      cols <- colorRampPalette(c("black", "darkorchid", "blueviolet", "magenta", "deeppink", "red4", "orange", "springgreen4"))
      col.overlay <- cols(length(overlay))
      
    }
   
  }else if(length(col) == 1){
    
    if(is.na(col[1])){
      
      cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
      col.pts <- densCols(fr.exprs[,channels], colramp = cols)
      
    }else{
      
      col.pts <- col[1]
      
    }
    
    if(!is.null(overlay)){
      
      cols <- colorRampPalette(c("darkorchid", "blueviolet", "magenta", "deeppink", "red4", "orange", "springgreen4", "navyblue"))
      col.overlay <- cols(length(overlay))
      
    }
    
  }else if(length(col) > 1){
    
    if(length(col) < length(smp)){
      
      if(is.na(col[1])){
        
        cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
        col.pts <- densCols(fr.exprs[,channels], colramp = cols)
        
      }else{
        
        col.pts <- col[1]
        
      }
      cols <- colorRampPalette(c("darkorchid", "blueviolet", "magenta", "deeppink", "red4", "orange", "springgreen4", "navyblue"))
      col.overlay <- c(col[2:length(col)], cols((smp-1) - length(col[2:length(col)])))
      
    }else if(length(col) > length(smp)){
      
      if(is.na(col[1])){
        
        cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
        col.pts <- densCols(fr.exprs[,channels], colramp = cols)
        
      }else{
        
        col.pts <- col[1]
        
      }
      col.overlay <- col[2:smp]
      
    }else{
    
      if(is.na(col[1])){
        
        cols <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
        col.pts <- densCols(fr.exprs[,channels], colramp = cols)
        
      }else{
        
        col.pts <- col[1]
        
      }
      col.overlay <- col[2:length(col)]
    
    }
    
  }else{
    
    col.overlay <- col[-1]
    
  }
  
  # Labels
  if(missing(xlab)){
    
    if(!is.na(fr.data$desc[which(fr.channels == channels[1])])){
      
      xlab <- paste(fr.data$desc[which(fr.channels == channels[1])], channels[1] , sep = " ")
      
    }else if(is.na(fr.data$desc[which(fr.channels == channels[1])])){
      
      xlab <- paste(channels[1], sep = " ")
      
    }
    
  }
  
  if(missing(ylab)){
    
    if(!is.na(fr.data$desc[which(fr.channels == channels[2])])){
      
      ylab <- paste(fr.data$desc[which(fr.channels == channels[2])], channels[2] , sep = " ")
      
    }else if(is.na(fr.data$desc[which(fr.channels == channels[2])])){
      
      ylab <- paste(channels[2], sep = " ")
      
    }
    
  }
  
  # Title
  if(missing(main)){
    
    main <- fr@description$GUID
    
  }
  
  # Alpha
  if(length(alpha) == 1){
    
    alpha.pts <- alpha[1]
    
    if(!is.null(overlay)){
      
      alpha.overlay <- rep(alpha, length(overlay))
      
    }
    
  }else if(length(alpha) < length(smp)){
    
    alpha.pts <- alpha[1]
    alpha.overlay <- c(alpha[2:length(alpha)], rep(1, (smp - length(alpha))))
    
  }else if(length(alpha) > length(smp)){
    
    alpha.pts <- alpha[1]
    alpha.overlay <- alpha[2:smp]
    
  }
  
  # Pop-up
  if(popup == TRUE){
    
    checkOSGD()
    
  }
  
  #Plot margins
  if(!is.null(overlay) & legend == TRUE){
    
    if(missing(text.legend)){
      
      mrgn <- 7 + max(nchar(c(fr@description$GUID,names(overlay))))*0.32
      
    }else{
      
      mrgn <- 7 + max(nchar(text.legend))*0.32
      
    }
    
    par(mar = c(5,5,4,mrgn) + 0.1)
    
    if(is.null(main)){
      
      par(mar = c(5,5,2,mrgn) + 0.1)
      
    }
    
    
  }else{
    
    par(mar = c(5,5,4,2) + 0.1)
    
    if(is.null(main)){
      
      par(mar = c(5,5,2,2) + 0.1)
      
    }
    
  }
  
  # Plot
  if (nrow(fr) < 2){
    
    graphics::plot(1, type = "n", axes = F, pch = pch, cex.pts = cex.pts, xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab, main = main, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, ...)
    
  }else{
    
    if(is.null(xlabels) & is.null(ylabels)){
      
      graphics::plot(fr.exprs, col = adjustcolor(col.pts, alpha.pts), pch = pch, main = main, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, cex = cex.pts, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, ...)
      
    }else if(!is.null(xlabels) & is.null(ylabels)){
      
      graphics::plot(fr.exprs, xaxt = "n", col = adjustcolor(col.pts, alpha.pts), pch = pch, main = main, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, cex = cex.pts, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, ...)
      axis(1, at = xlabels$at, labels = xlabels$label)
      
    }else if(is.null(xlabels) & !is.null(ylabels)){
      
      graphics::plot(fr.exprs, yaxt = "n", col = adjustcolor(col.pts, alpha.pts), pch = pch, main = main, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, cex = cex.pts, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, ...)
      axis(2, at = ylabels$at, labels = ylabels$label)
      
    }else if(!is.null(xlabels) & !is.null(ylabels)){
      
      graphics::plot(fr.exprs, xaxt = "n", yaxt = "n", col = adjustcolor(col.pts, alpha.pts), pch = pch, main = main, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, cex = cex.pts, cex.axis = cex.axis, col.axis = col.axis, cex.lab = cex.lab, col.lab = col.lab, cex.main = cex.main, col.main = col.main, ...)
      axis(1, at = xlabels$at, labels = xlabels$label)
      axis(2, at = ylabels$at, labels = ylabels$label)
      
    }
  }
  
  # Contour Lines
  if(contours != 0){
    
    # Calculate 2D kernel density using kde2d from MASS
    z <- MASS::kde2d(fr.exprs[,1], fr.exprs[,2], n = 75)
    
    # Add contour lines to plot
    graphics::contour(z = z$z, x = z$x, y = z$y, add = TRUE, drawlabels = FALSE, nlevels = contours, col = col.contour, lwd = lwd.contour)
    
    
  }
  
  # Add overlays
  if(!is.null(overlay)){
    
    mapply(function(overlay, col.overlay, alpha.overlay){
      
      points(x = exprs(overlay)[, channels[1]], y = exprs(overlay)[, channels[2]], pch = ".", col = adjustcolor(col.overlay, alpha.overlay), cex = cex.pts)
      
    }, overlay, col.overlay, alpha.overlay)
    
  }
  
  # Add legend
  if(!is.null(overlay) & legend == TRUE){
    
    # Legend position x
    legend.x <- par("usr")[2] + 0.025*par("usr")[2]
    
    # Legend position y
    legend.y <- mean(par("usr")[c(3,4)]) + (((par("usr")[4])/21)*0.5*smp)
    
    # Legend labels
    if(missing(text.legend)){
      
      text.legend <- c(fr@description$GUID, names(overlay))
      
    }
    
    # Legend colours
    if(missing(col)){
      
      col.pts <- "blue"
      
    }else if(is.na(col[1])){
      
      col.pts <- "blue"
      
    }
    
    # Legend with lines
    if(!missing(col.legend) & missing(fill.legend)){
      
      legend(x = legend.x, y = legend.y, legend = text.legend, col = col.legend, xpd = TRUE, bty = "n", x.intersp = 0.5)
      
    }else if(missing(col.legend) & !missing(fill.legend)){
      
      legend(x = legend.x, y = legend.y, legend = text.legend, fill = fill.legend, xpd = TRUE, bty = "n", x.intersp = 0.5)
      
    }else if(missing(col.legend) & missing(fill.legend)){
      
      legend(x = legend.x, y = legend.y, legend = text.legend, fill = c(col.pts, col.overlay), xpd = TRUE, bty = "n", x.intersp = 0.5)
      
    }
    
  }
  
  # Gates
  if(!is.null(gates)){
    
    plotGates(gates, channels = channels, col.gate = col.gate, lwd.gate = lwd.gate, lty.gate = lty.gate)
    
  }
  
  # Labels
  if(!is.null(gates) & labels == TRUE){
    
    if(class(gates) %in% c("rectangleGate","polygonGate","ellipsoidGate")){
      
      gates <- filters(list(gates))
      
    }else if(class(gates) == "list"){
      
      gates <- filters(gates)
      
    }else if(class(gates) == "filters"){
      
    }
    
    # Population names missing - show percantage only
    if(missing(text.labels)){
      
      plotLabels(x = fr, channels = channels, alias = NA, gates = gates, format.text = "percent", cex.text = cex.labels, font.text = font.labels, col.text = col.labels, alpha = alpha.labels)
      
    }else if(!missing(text.labels)){
      
      plotLabels(x = fr, channels = channels, alias = text.labels, gates = gates, format.text= format.labels, cex.text = cex.labels, font.text = font.labels, col.text = col.labels, alpha = alpha.labels)
      
    }
    
  }
  
  # Return options to default
  options(scipen = 0)
  
  # Return plot margins to default
  par(mar = c(5,4,4,2) + 0.1)
  
})

#' plotCyto2d - flowSet Method
#'
#' Visualise 2-D flow cytometry scatterplots with blue-red density colour scale
#' for a flowSet.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param channels names of channels or markers to be used to construct the
#'   plot.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transList object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transList will NOT be applied to the
#'   flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param merge logical indicating whether the flowFrames should be merged prior
#'   to plotting to yield a single plot, set to FALSE by default.
#' @param overlay a \code{flowFrame}, \code{flowSet}, \code{list of flowFrames},
#'   \code{list of flowSets} or \code{list of flowFrame lists} containing
#'   populations to be overlayed onto the plot(s).
#' @param subSample  numeric indicating the number of events to plot, set to all
#'   events by default. Reducing the sample size can significantly increase
#'   plotting speed on less powerful machines.
#' @param mfrow a vector of the length 2 indicating the dimensions of the grid
#'   for plotting \code{c(#rows, #columns)}.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of x axis (e.g. c(0,5)).
#' @param main title for the plot, set to the name of the sample by default.
#' @param ... additional arguments passed to \code{\link{plotCyto2d,flowFrame-method}}.
#'
#' @examples
#' \dontrun{
#'   fs <- Activation
#'   plotCyto2d(fs, channel = c("FSC-A","SSC-A"), overlay = fs[[2]], col = c(NA,"purple"))
#'   plotCyto2d(fs, channel = c("FSC-A","SSC-A"), overlay = fs[[2]], col = c("black","red"))
#'
#' }
#' 
#' @importFrom flowCore exprs parameters fsApply
#' @importFrom flowWorkspace pData sampleNames
#' @importFrom graphics plot axis title abline polygon contour legend points par
#' @importFrom grDevices densCols colorRampPalette n2mfrow
#' @importFrom methods as
#'
#' @seealso \code{\link{plotCyto2d,flowFrame-method}}
#' @seealso \code{\link{plotCyto,flowSet-method}}
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
setMethod(plotCyto2d, signature = "flowSet", definition = function(x, channels, transList = NULL, merge = FALSE, overlay = NULL, subSample = NULL, mfrow, popup = FALSE, limits = "machine", xlim = NULL, ylim = NULL, main,  ...){
  
  # Assign x to fs
  fs <- x
  fs.channels <- BiocGenerics::colnames(fs)
  
  # Sample names
  fsnms <- flowWorkspace::sampleNames(fs)
  
  # Check channels
  channels <- checkChannels(fs, channels = channels, plot = TRUE)
  
  # Prevent scientific notation
  options(scipen = 999)
  
  # X axis limits
  if(is.null(xlim)){
    
    if(limits == "data"){
      
      xlim <- suppressWarnings(axesLimits(x = fs, channels = channels, overlay = overlay, upper = TRUE)[[1]])
      
    }else if(limits == "machine"){
      
      xlim <- suppressWarnings(axesLimits(x = fs, channels = channels, overlay = overlay, upper = FALSE)[[1]])
      
    }
    
  }
  
  # Y axis limits
  if(is.null(ylim)){
    
    if(limits == "data"){
      
      ylim <- suppressWarnings(axesLimits(x = fs, channels = channels, overlay = overlay, upper = TRUE)[[2]])
      
    }else if(limits == "machine"){
      
      ylim <- suppressWarnings(axesLimits(x = fs, channels = channels, overlay = overlay, upper = FALSE)[[2]])
      
    }
    
  }
  
  # Merge?
  if(merge == TRUE){
    
    fr <- as(fs, "flowFrame")
    
    if(is.na(match("Original", BiocGenerics::colnames(fr))) == FALSE){
      
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      
    }
    
    if(missing(main)){
      
      main <- "Combined Events"
      
    }
    
    # overlay
    if(!is.null(overlay)){
      
      overlay <- checkOverlay(x = fr, overlay = overlay, subSample = subSample)
      
    }
    
    # mfrow
    if(missing(mfrow)){
      
      mfrow <-c(1,1)
      
    }
    
    # Plot
    plotCyto2d(x = fr, channels = channels, subSample = subSample, transList = transList, overlay = overlay, main = main, xlim = xlim, ylim = ylim, popup = popup, mfrow = mfrow, ...)
    
  }else if(merge == FALSE){
  
  # Number of samples
  smp <- length(fs)
  
  # Convert fs to list of flowFrames
  fs.lst <- lapply(seq(1,length(fs),1), function(x) fs[[x]])
  names(fs.lst) <- fsnms
  
  # subSample flowFrames
  if(!missing(subSample)){

    fs.lst <- lapply(fs.lst, function(x){
      
      sampleFrame(x, subSample)
      
    })
    
  }
  
  # Overlays
  if(is.null(overlay)){
    
    
  }else if(class(overlay) == "flowFrame"){
    
    # One flowFrame to be overlayed on all plots - add to list
    overlay <- list(overlay)
    
    # Repeat flowFrame in list fs.lst times - overlay is list of flowFrames
    overlay <- rep(overlay, length(fs))
    names(overlay) <- as.vector(sapply(overlay, function(x) x@description$GUID))
    
  }else if(class(overlay) == "flowSet"){
    
    # overlay must be same length as fs.lst
    if(length(overlay) != smp){
      
      stop("The number of flowFrames to overlay does not match the number of flowFrames in x.")
      
    }
    
    # One flowFrame to be overlaid per flowFrame in fs.lst - convert into list of flowFrames
    overlay <- lapply(seq(1,length(overlay),1), function(x) overlay[[x]])
    names(overlay) <- sampleNames(overlay)
    
  }else if(class(overlay) == "list"){
    
    # list of flowFrames
    if(all(as.vector(sapply(overlay, class)) == "flowFrame")){
      
      if(length(overlay) != smp){
        
        stop("Supplied list of flowFrames is not of the same length of x.")
        
      }else{
        
        names(overlay) <- as.vector(sapply(overlay, function(x) x@description$GUID))
        
      }
      
      # list of flowSets 
    }else if(all(as.vector(sapply(overlay,class)) == "flowSet")){
      
      # list of flowSets - each of length smp
      if(all(as.vector(sapply(overlay,length)) == smp)){
        
        # List of flowSets each of length smp - makes lists of a list of flowFrames
        overlay <- lapply(overlay, function(fs){
          
          lapply(seq(1,smp,1), function(x){
            
            fs[[x]]
            
          })
          
        })
        overlay <- lapply(1:smp, function(x){lapply(overlay, `[[`, x)})
        nms <- as.vector(sapply(overlay, function(x){sapply(x, function(y){y@description$GUID})}))
        lapply(1:length(overlay), function(x){names(overlay[[x]]) <<- nms[x]})

        # listsed flowSets not correct length  
      }else{
        
        stop("The length of each flowSet in overlay list is not equal to the number of flowFrames in x.")
        
      }
      
      # list of frame lists
    }else if(all(as.vector(sapply(overlay, class)) == "list")){
      
      # List of Frame lists - check each element of list == smp
      if(all(as.vector(sapply(overlay,length)) == smp)){
        
        overlay <- lapply(1:smp, function(x){lapply(overlay, `[[`, x)})
        nms <- sapply(overlay, function(x){sapply(x, function(y){y@description$GUID})})
        lapply(1:length(overlay), function(x){names(overlay[[x]]) <<- nms[,x]})
        
      }else{
        
        stop("The length of flowFrame list in overlay list is not equal to the number of flowFrames in x.")
        
      }
      
    }
    
  }
  
  # Pop-up
  if(popup == TRUE){
    
    checkOSGD()
    
  }
  
  # mfrow
  if(missing(mfrow)){
    
    mfrow <- c(n2mfrow(smp)[2], n2mfrow(smp)[1])
    par(mfrow = mfrow)
    
  }else if(!missing(mfrow)){
    
    if(mfrow[1] == FALSE){
      
      # Do nothing
      
    }else{
      
      par(mfrow = mfrow)
      
    }
    
  }
  
  # Number of plots in window
  np <- mfrow[1] * mfrow[2]
  
  # Titles
  if(missing(main)){
    
    main <- sampleNames(fs)
    
  }

  # Plot
  if(!is.null(overlay)){
    
    cnt <- 0
    mapply(function(fr, o, main){
      
      cnt <<- cnt + 1

      plotCyto2d(x = fr, channels = channels, transList = transList, overlay = o, main = main, xlim = xlim, ylim = ylim, ...)
      
      if(popup == TRUE & cnt %% np == 0 & length(fs.lst) > cnt){
        
        checkOSGD()
        
      } 
      
    }, fs.lst, overlay, main)
    
  }else{
    
    cnt <- 0
    mapply(function(fr, main){
      
      cnt <<- cnt + 1
      
      plotCyto2d(x = fr, channels = channels, transList = transList, main = main, xlim = xlim, ylim = ylim, ...)
      
      if(popup == TRUE & cnt %% np == 0 & length(fs.lst) > cnt){
        
        checkOSGD()
        
      }
      
    }, fs.lst, main)
    
  }
  
  }
  
  # Return mfrow to default
  if(!missing(mfrow)){
    
    if(mfrow[1] != FALSE){
    
      par(mfrow = c(1,1))
      
    }
    
  }
  
  # Return options to default
  options(scipen = 0)
  
})