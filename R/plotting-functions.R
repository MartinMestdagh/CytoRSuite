#' Boxed Labels - Modified plotrix
#' 
#' @param x,y  x and y position of the centers of the labels. \code{x} can be a xy.coords list.
#' @param bg The fill color of the rectangles on which the labels are displayed (see Details).
#' @param labels Text strings.
#' @param border Whether to draw borders around the rectangles.
#' @param xpad,ypad The proportion of the rectangles to the extent of the text within.
#' @param srt Rotation of the labels. if 90 or 270 degrees, the box will be rotated 90 degrees.
#' @param cex Character expansion. See \code{text}.
#' @param adj left/right adjustment. If this is set outside the function, the box will not be aligned properly.
#' @param xlog Whether the X axis is a log axis.
#' @param ylog Whether the y axis is a log axis.
#' @param alpha.bg Numeric [0,1] controlling the transparency of the background, set to 0.5 by default.
#' @param ... additional arguments passed to \code{text}.
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#' 
#' @importFrom graphics par strwidth strheight rect text
#' @importFrom grDevices col2rgb adjustcolor
#' @importFrom utils modifyList
#' 
#' @noRd
boxed.labels <- function(x, y = NA, labels,
                         bg = ifelse(match(par("bg"), "transparent", 0), "white", par("bg")),
                         border = NA, xpad = 1.2, ypad = 1.2, 
                         srt = 0, cex = 1, adj = 0.5, xlog = FALSE, ylog = FALSE, alpha.bg = 0.5, ...) {
  
  border <- NA
  oldpars <- par(c("cex", "xpd"))
  par(cex = cex, xpd = TRUE)
  if (is.na(y) && is.list(x)) {
    y <- unlist(x[[2]])
    x <- unlist(x[[1]])
  }
  box.adj <- adj + (xpad - 1) * cex * (0.5 - adj)
  if (srt == 90 || srt == 270) {
    bheights <- strwidth(labels)
    theights <- bheights * (1 - box.adj)
    bheights <- bheights * box.adj
    lwidths <- rwidths <- strheight(labels) * 0.5
  }
  else {
    lwidths <- strwidth(labels)
    rwidths <- lwidths * (1 - box.adj)
    lwidths <- lwidths * box.adj
    bheights <- theights <- strheight(labels) * 0.5
  }
  args <- list(x = x, y = y, labels = labels, srt = srt, adj = adj, 
               col = ifelse(colSums(col2rgb(bg) * c(1, 1.4, 0.6)) < 
                              350, "white", "black"))
  args <- modifyList(args, list(...))
  if(xlog){
    xpad<-xpad*2
    xr<-exp(log(x) - lwidths * xpad)
    xl<-exp(log(x) + lwidths * xpad)
  }
  else{
    xr<-x - lwidths * xpad
    xl<-x + lwidths * xpad
  }
  if(ylog){
    ypad<-ypad*2
    yb<-exp(log(y) - bheights * ypad)
    yt<-exp(log(y) + theights * ypad)
  }
  else{
    yb<-y - bheights * ypad
    yt<-y + theights * ypad
  }	
  rect(xr, yb, xl, yt, col = adjustcolor(col = bg, alpha.f = alpha.bg), border = border)
  do.call(text, args)
  par(cex = oldpars)
}

#' Get Appropriate Axes Labels for Transformed Channels - flowWorkspace
#' 
#' @param x object of class \code{flowFrame} or \code{GatingHierarchy}.
#' @param ... additional arguments.
#' 
#' @return list containing axis labels and breaks.
#' 
#' @export
setGeneric(name = "axisLabels",
           def = function(x, ...){standardGeneric("axisLabels")}
)

#' Get Appropriate Axes Labels for Transformed Channels - flowFrame Method
#'
#' @param x an object of class \code{flowFrame}.
#' @param channel name of the channel.
#' @param transList object of class \code{"transformList"} or
#'   \code{"transformerList"} generated by estimateLogicle containing the
#'   transformations applied to the flowFrame.
#'
#' @return list containing axis labels and breaks.
#'
#' @importFrom flowCore transformList inverseLogicleTransform
#'
#' @export
setMethod(axisLabels, signature = "flowFrame", definition = function(x, channel, transList){
  
  if(is.null(transList) | !class(transList)[1] %in%  c("transformList","transformerList")){
    
    stop("Please supply a valid transformList containing the transformations applied to the flowFrame.")
    
  }
  
  if(class(transList)[1] == "transformerList"){
    
    trns <- lapply(transList, `[[`, "transform")
    transList <- transformList(names(trns), trns)
    
  }
  
  if(!channel %in% names(transList@transforms)){
    
    # Channel not listed in trans object
    return(NULL)
    
  }
  
  fr <- x
  
  # Range of values
  r <- as.vector(range(fr)[,channel])

  # Transformation Functions & Breaks
  trans.func <- transList@transforms[[channel]]@f
  inv.func <- inverseLogicleTransform(transList)@transforms[[channel]]@f
  raw <- inv.func(r)
  brks <- flowBreaks(raw, n = 5, equal.space = FALSE)

  
  pos <- signif(trans.func(brks))
  label <- .pretty10exp(brks, drop.1 = TRUE)
  
  res <- list(label = label, at = pos)
  
  return(res)

})

#' Get Appropriate Axes Labels for Transformed Channels - GatingHierarchy Method
#'
#' @param x \code{GatingHiearchy}.
#' @param channel \code{character} channel name.
#'
#' @return when there is transformation function associated with the given
#'   channel, it returns a list of that contains positions and labels to draw on
#'   the axis otherwise returns NULL.
#'
#' @export
setMethod(axisLabels, signature = "GatingHierarchy", definition = function(x, channel){
  
  gh <- x
  res <- gh@axis[[sampleNames(gh)]][[channel]] #this call is to be deprecated once we figure out how to preserve trans when cloning GatingSet
  if(is.null(res)){
    #try to grab trans and do inverse trans for axis label on the fly
    trans <- getTransformations(gh, channel, only.function = FALSE)
    if(is.null(trans)){
      res <- NULL
    }else{
      inv.func <- trans[["inverse"]]
      trans.func <- trans[["transform"]]
      brk.func <- trans[["breaks"]]
      
      fr <- getData(gh, use.exprs = FALSE)
      r <- as.vector(range(fr)[,channel])#range
      raw <- inv.func(r)
      brks <- brk.func(raw)
      pos <- signif(trans.func(brks))
      #format it
      label <- trans[["format"]](brks)
      
      res <- list(label = label, at = pos)
    }
    
  }else{
    #use the stored axis label if exists
    res$label <- .pretty10exp(as.numeric(res$label),drop.1=TRUE)
  }
  
  return(res)
})

#' Generate the breaks that makes sense for flow data visualization - flowWorkspace
#'
#' It is mainly used as helper function to construct breaks function used by 'trans_new'.
#'
#' @return either 10^n intervals or equal-spaced(after transformed) intervals in raw scale.
#' @param n desired number of breaks (the actual number will be different depending on the data range)
#' @param x the raw data values
#' @param equal.space whether breaks at equal-spaced intervals
#' @param trans.fun the transform function (only needed when equal.space is TRUE)
#' @param inverse.fun the inverse function (only needed when equal.space is TRUE)
#' 
#' @noRd
flowBreaks <- function(x, n = 6, equal.space = FALSE, trans.fun, inverse.fun){
  
  rng.raw <- range(x, na.rm = TRUE)
  if(equal.space){
    
    rng <- trans.fun(rng.raw)
    min <- floor(rng[1])
    max <- ceiling(rng[2])
    if (max == min)
      return(inverse.fun(min))
    by <- (max - min)/(n-1)
    
    myBreaks <- inverse.fun(seq(min, max, by = by))
    
  }else{
    #log10 (e.g. 0, 10, 1000, ...)
    base10raw <- unlist(lapply(2:n,function(e)10^e))
    base10raw <- c(0,base10raw)
    myBreaks <- base10raw[base10raw > rng.raw[1] & base10raw < rng.raw[2]]
    
  }
  
  myBreaks
  
}

# copy from sfsmisc/flowWorkspace package
# modified to handle NA values
.pretty10exp <- function (x, drop.1 = FALSE, digits.fuzz = 7){
  
  eT <- floor(log10(abs(x)) + 10^-digits.fuzz)
  mT <- signif(x/10^eT, digits.fuzz)
  ss <- vector("list", length(x))
  
  for (i in seq(along = x)) ss[[i]] <- if (is.na(x[i]))
    quote(NA)
  else if (x[i] == 0)
    quote(0)
  else if (drop.1 && mT[i] == 1)
    substitute(10^E, list(E = eT[i]))
  else if (drop.1 && mT[i] == -1)
    substitute(-10^E, list(E = eT[i]))
  else substitute(A %*% 10^E, list(A = mT[i], E = eT[i]))
  
  do.call("expression", ss)
  
}

#' Get Axes Limits
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param parent name of the parental node to extract from GatingHierarchy or
#'   GatingSet.
#' @param channels name of the channels or markers to be used to construct the
#'   plot.
#' @param overlay a \code{flowFrame}, \code{flowSet}, \code{list of flowFrames},
#'   \code{list of flowSets} or \code{list of flowFrame lists} containing
#'   populations to be overlayed onto the plot(s). Data for overlays will be
#'   merged with \code{x} prior to axis limit calculation to ensure that the
#'   axes limits are set based on all the data to be included in the plot.
#' @param limits indicates whether the limits of the "data" or limits of the
#'   "machine" should be returned. This argument will only influence the upper
#'   limit. The lower limit will always be set to 0, unless the data contains
#'   values below this limit. In such cases the lower limit of the data will be
#'   used instead. This argument is set to "machine" by default.
#'
#' @importFrom flowCore exprs flowSet parameters
#' @importFrom flowWorkspace pData
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.getAxisLimits <- function(x, parent = "root", channels, overlay = NULL, limits = "machine"){
  
  # Missing channels
  if(missing(channels)){
    
    stop("Please supply the names of the channel(s) to calculate axes limits.")
    
  }else{
    
    checkChannels(x = x, channels = channels, plot = FALSE)
    
  }
  
  # Incorrect limits argument
  if(!limits %in% c("data","machine")){
    
    stop("Limits argument should be either 'data' or 'machine'.")
    
  }
  
  # x is a flowFrame
  if(inherits(x, "flowFrame")){
    
    fr <- x
    
  # x is a flowSet
  }else if(inherits(x, "flowSet")){
    
    fr <- as(x, "flowSet")
    
    if("Original" %in% BiocGenerics::colnames(fr)){
      
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      
    }
    
  # x is a GatingHierarchy  
  }else if(inherits(x, "GatingHierarchy")){
    
    fr <- getData(x, parent)
    
  # x is a GatingSet  
  }else if(inherits(x, "GatingSet")){
    
    fr <- as(getData(x, parent), "flowFrame")
    
    if("Original" %in% BiocGenerics::colnames(fr)){
      
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      
    }
    
  }
  
  # Assign x to fr
  fr <- x

  # Extract summary stats
  sm <- pData(parameters(fr))
  
  lms <- lapply(channels, function(channel){
    
    # Extract machine limits
    mlms <- vector()
    mlms[1] <- sm[sm$name == channel, "minRange"]
    mlms[2] <- sm[sm$name == channel, "maxRange"]
    
    if(mlms[1] > 0){
        
      mlms <- c(0, mlms[2])
      
    }
    
    # Machine limits
    if(limits == "machine"){

      lms <- mlms
    
    # Data limits
    }else if(limits == "data"){
    
      # No overlay
      if(is.null(overlay)){
    
       # overlay
      }else if(!is.null(overlay)){
    
         # Get merged flowFrame to calculate axes limits
         # flowFrame
         if(class(overlay) == "flowFrame"){
      
          fr <- as(flowSet(list(fr,overlay)),"flowFrame")
      
         # flowSet  
         }else if(class(overlay) == "flowSet"){
      
           ov <- as(overlay, "flowFrame")
      
           if(is.na(match("Original", BiocGenerics::colnames(ov))) == FALSE){
        
               ov <- ov[, -match("Original", BiocGenerics::colnames(ov))]
          
           }
           fr <- as(flowSet(list(fr,ov)),"flowFrame")
      
         # list 
         }else if(class(overlay) == "list"){
      
           # list of flowFrames
          if(all(as.vector(sapply(overlay, function(x) {class(x)})) == "flowFrame"))
      
            fr <- as(flowSet(c(list(fr),overlay)),"flowFrame")
        
           # list of flowSets
           }else if(all(as.vector(sapply(overlay, function(x) {class(x)})) == "flowFrame")){
       
             ov <- lapply(overlay, function(x){as(x,"flowFrame")})
        
            if(is.na(match("Original", BiocGenerics::colnames(ov[[1]]))) == FALSE){
          
               ov <- lapply(ov,function(fr){
            
                 fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]
            
                 return(fr)
            
               })
        
             }
             fr <- as(flowSet(c(list(fr), ov)),"flowFrame")
        
           # list of lists   
           }else if(all(as.vector(sapply(overlay, function(x) {class(x)})) == "list")){
        
             # flowFrame lists
             if(all(as.vector(sapply(overlay, function(x) {sapply(x,class)})) == "flowFrame")){
          
               fr.lst <- lapply(overlay, function(x){
            
                as(flowSet(x),"flowFrame")
            
               })
          
               if(is.na(match("Original", BiocGenerics::colnames(fr.lst[[1]]))) == FALSE){
            
                 ov <- lapply(fr.lst,function(fr){
              
                   fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]
              
                   return(fr)
              
                 })
            
               }
               fr <- as(flowSet(c(list(fr),ov)),"flowFrame")
          
             }
        
              # flowSet lists
             if(all(as.vector(sapply(overlay, function(x) {sapply(x,class)})) == "flowSet")){
          
               fr.lst <- lapply(overlay, function(x){
            
                 as(x,"flowFrame")
            
               })
          
               if(is.na(match("Original", BiocGenerics::colnames(fr.lst[[1]]))) == FALSE){
            
                 ov <- lapply(fr.lst,function(fr){
              
                   fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]
              
                   return(fr)
              
                  })
          
               fr <- as(flowSet(c(list(fr),ov)),"flowFrame")
          
               }
          
            }
    
         }
    
       }
  
     # Limits from flowFrame
     lms <- range(exprs(fr)[,channel])
     lms <- c(mlms[1], lms[2])
    
    }
    
    return(lms)
    
  })
  
  names(lms) <- channels
  
  return(lms)

}

#' Merge overlay for merged data
#'
#' @param x flowSet data to be merged.
#' @param overlay object generated by checkOverlay flowSet method (list of
#'   flowFrame lists).
#' @param mergeBy pData variables of x used to merge the data. To merge all
#'   samples set mergeBy to "all".
#' @param subSample numeric indicating the number of events to include.
#'
#' @noRd
.mergeOverlay <- function(x, overlay, mergeBy = "all", subSample = NULL){
  
  # x is flowSet prior to merging
  if(!class(x)[1] %in% c("flowSet","GatingSet") | length(overlay) != length(x)){
    
    stop("Supply the original data prior to merging.")
    
  }
  
  # Extract pData
  pd <- pData(x)
  
  # List of group indicies - ind
  if(length(mergeBy) == 1 & mergeBy[1] == "all"){
    
    grps <- list(1:length(x))
    
  }else{
    
    # Groups
    if(length(mergeBy) == 1){
      
      pd$mrg <- pd[, mergeBy]
      
    }else{
      
      pd$mrg <- do.call("paste", pd[, mergeBy])
      
    }
    
    # Get a list of indices per group
    grps <- lapply(unique(pd$mrg), function(x){
      
      which(pd$mrg == x)
      
    })
    
  }
  
  # Subset overlay, merge & subSample
  overlay <- lapply(grps, function(x){
      
    ov <- overlay[x]
    
    lapply(seq(1,length(ov[[1]]),1), function(x){
        
      fr.lst <- lapply(ov, `[[`, x)
      
      # if same flowFrame return first only
      if(length(unique(fr.lst)) == 1 | length(unique(sapply(fr.lst, function(x){x@description$GUID}))) == 1){
        
        fr <- fr.lst[[1]]
        
      }else{
      
        fs <- flowSet()
      
        fr <- as(fs, "flowFrame")
        
        if("Original" %in% BiocGenerics::colnames(fr)){
        
          fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
          
        }
        
      }
      
      if(!is.null(subSample)){
          
        fr <- Subset(fr, sampleFilter(size = subSample))
          
      }
      
      return(fr)
        
    })
      
  })
  
  return(overlay)
  
}

#' Merge samples by pData
#'
#' @param x flowSet or GatingSet object
#' @param parent name of the parent population to extract from GatingSet object.
#' @param mergeBy names of pData variables to use for merging. Set to "all" to
#'   merge all samples in the flowSet.
#'   
#' @return list containing merged flowFrames, named with group.
#'
#' @noRd
.mergeBy <- function(x, parent = "root", mergeBy = "all"){
  
  # check x
  if(inherits(x, "flowFrame") | inherits(x, "GatingHierarchy")){
    
    stop("x must be either a flowSet or a GtaingSet object.")
    
  }
  
  # check mergeBy
  if(all(!mergeBy %in% c("all", colnames(pData(x))))){
    
    stop("mergeBy should be the name of pData variables or 'all'.")
    
  }
  
  # Extract pData information
  pd <- pData(x)
  
  # flowSet for merging
  if(inherits(x, "GatingSet")){
    
    fs <- getData(x, parent)
    
  }else{
    
    fs <- x
    
  }
  
  # merge all samples
  if(length(mergeBy) == 1 & mergeBy[1] == "all"){
    
    pd$merge <- rep("all", length(x))
    
    fr <- as(fs, "flowFrame")
    
    if("Original" %in% BiocGenerics::colnames(fr)){
      
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      
    }
    
    fr.lst <- list(fr)
    
  # merge by one variable
  }else if(length(mergeBy) == 1){
    
    pd$merge <- pd[, mergeBy]
    
    fr.lst <- lapply(unique(pd$merge), function(x){
      
      fr <- as(fs[pd$merge == x], "flowFrame")
      
      if("Original" %in% BiocGenerics::colnames(fr)){
        
        fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
        
      }
      
      return(fr)
      
    })
    
  # merge by multiple variables  
  }else{
    
    pd$merge <- do.call("paste", pd[, mergeBy])
    
    fr.lst <- lapply(unique(pd$merge), function(x){
      
      fr <- as(fs[pd$merge == x], "flowFrame")
      
      if("Original" %in% BiocGenerics::colnames(fr)){
        
        fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
        
      }
      
      return(fr)
      
    })
    
  }
  names(fr.lst) <- unique(pd$merge)
  
  return(fr.lst)
  
}