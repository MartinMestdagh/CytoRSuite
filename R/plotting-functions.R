#' Boxed Labels - Modified plotrix
#'
#' @param x,y  x and y position of the centers of the labels. \code{x} can be a xy.coords list.
#' @param bg The fill color of the rectangles on which the labels are displayed (see Details).
#' @param labels Text strings.
#' @param border Whether to draw borders around the rectangles.
#' @param xpad,ypad The proportion of the rectangles to the extent of the text within.
#' @param srt Rotation of the labels. if 90 or 270 degrees, the box will be rotated 90 degrees.
#' @param cex Character expansion. See \code{text}.
#' @param adj left/right adjustment. If this is set outside the function, the box will not be aligned properly.
#' @param xlog Whether the X axis is a log axis.
#' @param ylog Whether the y axis is a log axis.
#' @param alpha.bg Numeric [0,1] controlling the transparency of the background, set to 0.5 by default.
#' @param ... additional arguments passed to \code{text}.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @importFrom graphics par strwidth strheight rect text
#' @importFrom grDevices col2rgb adjustcolor
#' @importFrom utils modifyList
#'
#' @noRd
boxed.labels <- function(x, y = NA, labels,
                         bg = ifelse(match(par("bg"), "transparent", 0), "white", par("bg")),
                         border = NA, xpad = 1.2, ypad = 1.2,
                         srt = 0, cex = 1, adj = 0.5, xlog = FALSE, ylog = FALSE, alpha.bg = 0.5, ...) {
  border <- NA
  oldpars <- par(c("cex", "xpd"))
  par(cex = cex, xpd = TRUE)
  if (is.na(y) && is.list(x)) {
    y <- unlist(x[[2]])
    x <- unlist(x[[1]])
  }
  box.adj <- adj + (xpad - 1) * cex * (0.5 - adj)
  if (srt == 90 || srt == 270) {
    bheights <- strwidth(labels)
    theights <- bheights * (1 - box.adj)
    bheights <- bheights * box.adj
    lwidths <- rwidths <- strheight(labels) * 0.5
  }
  else {
    lwidths <- strwidth(labels)
    rwidths <- lwidths * (1 - box.adj)
    lwidths <- lwidths * box.adj
    bheights <- theights <- strheight(labels) * 0.5
  }
  args <- list(
    x = x, y = y, labels = labels, srt = srt, adj = adj,
    col = ifelse(colSums(col2rgb(bg) * c(1, 1.4, 0.6)) <
      350, "white", "black")
  )
  args <- modifyList(args, list(...))
  if (xlog) {
    xpad <- xpad * 2
    xr <- exp(log(x) - lwidths * xpad)
    xl <- exp(log(x) + lwidths * xpad)
  }
  else {
    xr <- x - lwidths * xpad
    xl <- x + lwidths * xpad
  }
  if (ylog) {
    ypad <- ypad * 2
    yb <- exp(log(y) - bheights * ypad)
    yt <- exp(log(y) + theights * ypad)
  }
  else {
    yb <- y - bheights * ypad
    yt <- y + theights * ypad
  }
  rect(xr, yb, xl, yt, col = adjustcolor(col = bg, alpha.f = alpha.bg), border = border)
  do.call(text, args)
  par(cex = oldpars)
}

#' Get Appropriate Axes Labels for Transformed Channels - flowWorkspace
#'
#' @param x object of class \code{flowFrame} or \code{GatingHierarchy}.
#' @param ... additional arguments.
#'
#' @return list containing axis labels and breaks.
#'
#' @export
setGeneric(
  name = "axesLabels",
  def = function(x, ...) {
    standardGeneric("axesLabels")
  }
)

#' Get Appropriate Axes Labels for Transformed Channels - flowFrame Method
#'
#' @param x an object of class \code{flowFrame}.
#' @param channels name(s) of the channel(s) used to construct the plot.
#' @param transList object of class \code{"transformList"} or
#'   \code{"transformerList"} generated by estimateLogicle containing the
#'   transformations applied to the flowFrame.
#'
#' @return list containing axis labels and breaks.
#'
#' @importFrom flowCore transformList inverseLogicleTransform
#'
#' @export
setMethod(axesLabels, signature = "flowFrame", definition = function(x, channels, transList = NULL) {
  
  # Return NULL if transList is missing
  if(is.null(transList)){
    
    return(NULL)
    
  }else{
    
    # transList of incorrect class
    if(!any(inherits(transList, "transformList") | inherits(transList, "transformerList"))){
      stop("Please supply a valid transformList containing the transformations applied to the flowFrame.")
    }
    
  }

  # Convert transformerList to transformList
  if (inherits(transList, "transformerList")) {
    trns <- lapply(transList, `[[`, "transform")
    transList <- transformList(names(trns), trns)
  }

  # Assign x to fr
  fr <- x

  # Get list of axis breaks and labels
  axs <- lapply(channels, function(channel){
    
    # Channel not included in transList
    if (!channel %in% names(transList@transforms)) {

      return(NULL)
      
    }
    
    # Range of values
    r <- as.vector(range(fr)[, channel])

    # Transformation Functions & Breaks
    trans.func <- transList@transforms[[channel]]@f
    inv.func <- inverseLogicleTransform(transList)@transforms[[channel]]@f
    raw <- inv.func(r)
    brks <- flowBreaks(raw, n = 5, equal.space = FALSE)


    pos <- signif(trans.func(brks))
    label <- .pretty10exp(brks, drop.1 = TRUE)

    res <- list(label = label, at = pos)
  
    return(res)
    
  })
  names(axs) <- channels
  
  return(axs)
})

#' Get Appropriate Axes Labels for Transformed Channels - GatingHierarchy Method
#'
#' @param x \code{GatingHiearchy}.
#' @param channels \code{character} name(s) of the channel(S) used to construct the plot.
#'
#' @return when there is transformation function associated with the given
#'   channel, it returns a list of that contains positions and labels to draw on
#'   the axis otherwise returns NULL.
#'
#' @export
setMethod(axesLabels, signature = "GatingHierarchy", definition = function(x, channels) {
  
  # Assign x to gh
  gh <- x
  
  # Get list of axis breaks and labels
  axs <- lapply(channels, function(channel){
    
    res <- gh@axis[[sampleNames(gh)]][[channel]]
    if (is.null(res)) {
      # try to grab trans and do inverse trans for axis label on the fly
      trans <- getTransformations(gh, channel, only.function = FALSE)
      if (is.null(trans)) {
        res <- NULL
      } else {
        inv.func <- trans[["inverse"]]
        trans.func <- trans[["transform"]]
        brk.func <- trans[["breaks"]]

        fr <- getData(gh, use.exprs = FALSE)
        r <- as.vector(range(fr)[, channel]) # range
        raw <- inv.func(r)
        brks <- brk.func(raw)
        pos <- signif(trans.func(brks))
        # format it
        label <- trans[["format"]](brks)

        res <- list(label = label, at = pos)
      }
    } else {
      # use the stored axis label if exists
      res$label <- .pretty10exp(as.numeric(res$label), drop.1 = TRUE)
    }

    return(res)
    
  })
  names(axs) <- channels

  return(axs)
  
})

#' Generate the breaks that makes sense for flow data visualization - flowWorkspace
#'
#' It is mainly used as helper function to construct breaks function used by 'trans_new'.
#'
#' @return either 10^n intervals or equal-spaced(after transformed) intervals in raw scale.
#' @param n desired number of breaks (the actual number will be different depending on the data range)
#' @param x the raw data values
#' @param equal.space whether breaks at equal-spaced intervals
#' @param trans.fun the transform function (only needed when equal.space is TRUE)
#' @param inverse.fun the inverse function (only needed when equal.space is TRUE)
#'
#' @noRd
flowBreaks <- function(x, n = 6, equal.space = FALSE, trans.fun, inverse.fun) {
  rng.raw <- range(x, na.rm = TRUE)
  if (equal.space) {
    rng <- trans.fun(rng.raw)
    min <- floor(rng[1])
    max <- ceiling(rng[2])
    if (max == min) {
      return(inverse.fun(min))
    }
    by <- (max - min) / (n - 1)

    myBreaks <- inverse.fun(seq(min, max, by = by))
  } else {
    # log10 (e.g. 0, 10, 1000, ...)
    base10raw <- unlist(lapply(2:n, function(e) 10^e))
    base10raw <- c(0, base10raw)
    myBreaks <- base10raw[base10raw > rng.raw[1] & base10raw < rng.raw[2]]
  }

  myBreaks
}

# copy from sfsmisc/flowWorkspace package
# modified to handle NA values
.pretty10exp <- function(x, drop.1 = FALSE, digits.fuzz = 7) {
  eT <- floor(log10(abs(x)) + 10^-digits.fuzz)
  mT <- signif(x / 10^eT, digits.fuzz)
  ss <- vector("list", length(x))

  for (i in seq(along = x)) ss[[i]] <- if (is.na(x[i])) {
      quote(NA)
    } else if (x[i] == 0) {
      quote(0)
    } else if (drop.1 && mT[i] == 1) {
      substitute(10^E, list(E = eT[i]))
    } else if (drop.1 && mT[i] == -1) {
      substitute(-10^E, list(E = eT[i]))
    } else {
      substitute(A %*% 10^E, list(A = mT[i], E = eT[i]))
    }

  do.call("expression", ss)
}

#' Get Axes Limits
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param parent name of the parental node to extract from GatingHierarchy or
#'   GatingSet.
#' @param channels name of the channels or markers to be used to construct the
#'   plot.
#' @param overlay a \code{flowFrame}, \code{flowSet}, \code{list of flowFrames},
#'   \code{list of flowSets} or \code{list of flowFrame lists} containing
#'   populations to be overlayed onto the plot(s). Data for overlays will be
#'   merged with \code{x} prior to axis limit calculation to ensure that the
#'   axes limits are set based on all the data to be included in the plot.
#' @param limits indicates whether the limits of the "data" or limits of the
#'   "machine" should be returned. This argument will only influence the upper
#'   limit. The lower limit will always be set to 0, unless the data contains
#'   values below this limit. In such cases the lower limit of the data will be
#'   used instead. This argument is set to "machine" by default.
#'
#' @importFrom flowCore exprs flowSet parameters
#' @importFrom flowWorkspace pData
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.getAxesLimits <- function(x, parent = "root", channels, overlay = NULL, limits = "machine") {

  # Missing channels
  if (missing(channels)) {
    stop("Please supply the names of the channel(s) to calculate axes limits.")
  } else {
    channels <- checkChannels(x = x, channels = channels, plot = FALSE)
  }

  # Incorrect limits argument
  if (!limits %in% c("data", "machine")) {
    stop("Limits argument should be either 'data' or 'machine'.")
  }

  # x is a flowFrame
  if (inherits(x, "flowFrame")) {
    fr <- x

    # x is a flowSet
  } else if (inherits(x, "flowSet")) {
    fr <- as(x, "flowFrame")

    if ("Original" %in% BiocGenerics::colnames(fr)) {
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
    }

    # x is a GatingHierarchy
  } else if (inherits(x, "GatingHierarchy")) {
    fr <- getData(x, parent)

    # x is a GatingSet
  } else if (inherits(x, "GatingSet")) {
    fr <- as(getData(x, parent), "flowFrame")

    if ("Original" %in% BiocGenerics::colnames(fr)) {
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
    }
  }

  # Extract summary stats
  sm <- pData(parameters(fr))

  lms <- lapply(channels, function(channel) {

    # Extract machine limits
    mlms <- vector()
    mlms[1] <- sm[sm$name == channel, "minRange"]
    mlms[2] <- sm[sm$name == channel, "maxRange"]

    if (mlms[1] > 0) {
      mlms <- c(0, mlms[2])
    }

    # Add 10% buffer on lower limit
    rng <- 0.1 * (mlms[2] - mlms[1])
    mlms <- c(mlms[1] - rng, mlms[2])

    # Machine limits
    if (limits == "machine") {
      lms <- mlms

      # Data limits
    } else if (limits == "data") {

      # No overlay
      if (is.null(overlay)) {

        # overlay
      } else if (!is.null(overlay)) {

        # Get merged flowFrame to calculate axes limits
        # flowFrame
        if (class(overlay) == "flowFrame") {
          fr <- as(flowSet(list(fr, overlay)), "flowFrame")

          # flowSet
        } else if (class(overlay) == "flowSet") {
          ov <- as(overlay, "flowFrame")

          if (is.na(match("Original", BiocGenerics::colnames(ov))) == FALSE) {
            ov <- ov[, -match("Original", BiocGenerics::colnames(ov))]
          }
          fr <- as(flowSet(list(fr, ov)), "flowFrame")

          # list
        } else if (class(overlay) == "list") {

          # list of flowFrames
          if (all(as.vector(sapply(overlay, function(x) {
            class(x)
          })) == "flowFrame")) {
            fr <- as(flowSet(c(list(fr), overlay)), "flowFrame")
          }

          # list of flowSets
        } else if (all(as.vector(sapply(overlay, function(x) {
          class(x)
        })) == "flowFrame")) {
          ov <- lapply(overlay, function(x) {
            as(x, "flowFrame")
          })

          if (is.na(match("Original", BiocGenerics::colnames(ov[[1]]))) == FALSE) {
            ov <- lapply(ov, function(fr) {
              fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]

              return(fr)
            })
          }
          fr <- as(flowSet(c(list(fr), ov)), "flowFrame")

          # list of lists
        } else if (all(as.vector(sapply(overlay, function(x) {
          class(x)
        })) == "list")) {

          # flowFrame lists
          if (all(as.vector(sapply(overlay, function(x) {
            sapply(x, class)
          })) == "flowFrame")) {
            fr.lst <- lapply(overlay, function(x) {
              as(flowSet(x), "flowFrame")
            })

            if (is.na(match("Original", BiocGenerics::colnames(fr.lst[[1]]))) == FALSE) {
              ov <- lapply(fr.lst, function(fr) {
                fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]

                return(fr)
              })
            }
            fr <- as(flowSet(c(list(fr), ov)), "flowFrame")
          }

          # flowSet lists
          if (all(as.vector(sapply(overlay, function(x) {
            sapply(x, class)
          })) == "flowSet")) {
            fr.lst <- lapply(overlay, function(x) {
              as(x, "flowFrame")
            })

            if (is.na(match("Original", BiocGenerics::colnames(fr.lst[[1]]))) == FALSE) {
              ov <- lapply(fr.lst, function(fr) {
                fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]

                return(fr)
              })

              fr <- as(flowSet(c(list(fr), ov)), "flowFrame")
            }
          }
        }
      }

      # Limits from flowFrame
      lms <- range(exprs(fr)[, channel])
      lms <- c(mlms[1], lms[2] + (0.1 * (lms[2] - mlms[1])))
    }

    return(lms)
  })

  names(lms) <- channels

  return(lms)
}

#' Merge overlay for merged data
#'
#' @param x flowSet data to be merged.
#' @param overlay object generated by checkOverlay flowSet method (list of
#'   flowFrame lists).
#' @param mergeBy pData variables of x used to merge the data. To merge all
#'   samples set mergeBy to "all".
#' @param subSample numeric indicating the number of events to include.
#'
#' @noRd
.mergeOverlay <- function(x, overlay, mergeBy = "all", subSample = NULL) {

  # x is flowSet prior to merging
  if (!class(x)[1] %in% c("flowSet", "GatingSet") | length(overlay) != length(x)) {
    stop("Supply the original data prior to merging.")
  }

  # Extract pData
  pd <- pData(x)

  # Sort pd by mergeBy column names
  if (mergeBy[1] != "all") {
    pd <- pd[do.call("order", pd[mergeBy]), ]
  }

  # Find new indicies
  ind <- match(sampleNames(fs), pd$name)

  # Reorder overlays based on merge levels
  overlay <- overlay[ind]

  # List of group indicies - ind
  if (length(mergeBy) == 1 & mergeBy[1] == "all") {
    grps <- list(1:length(x))
  } else {

    # Groups
    if (length(mergeBy) == 1) {
      pd$mrg <- pd[, mergeBy]
    } else {
      pd$mrg <- do.call("paste", pd[, mergeBy])
    }

    # Get a list of indices per group
    grps <- lapply(unique(pd$mrg), function(x) {
      which(pd$mrg == x)
    })
  }

  # Subset overlay, merge & subSample
  overlay <- lapply(grps, function(x) {
    ov <- overlay[x]

    lapply(seq(1, length(ov[[1]]), 1), function(x) {
      fr.lst <- lapply(ov, `[[`, x)

      # if same flowFrame return first only
      if (length(unique(fr.lst)) == 1 | length(unique(sapply(fr.lst, function(x) {
        x@description$GUID
      }))) == 1) {
        fr <- fr.lst[[1]]
      } else {
        fs <- flowSet(fr.lst)

        fr <- as(fs, "flowFrame")

        if ("Original" %in% BiocGenerics::colnames(fr)) {
          fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
        }
      }

      if (!is.null(subSample)) {
        fr <- Subset(fr, sampleFilter(size = subSample))
      }

      return(fr)
    })
  })

  return(overlay)
}

#' Merge samples by pData
#'
#' @param x flowSet or GatingSet object
#' @param parent name of the parent population to extract from GatingSet object.
#' @param mergeBy names of pData variables to use for merging. Set to "all" to
#'   merge all samples in the flowSet.
#' @param subSample number of events to include in each group.
#'
#' @return list containing merged flowFrames, named with group.
#'
#' @noRd
.mergeBy <- function(x, parent = "root", mergeBy = "all", subSample = NULL) {

  # check x
  if (inherits(x, "flowFrame") | inherits(x, "GatingHierarchy")) {
    stop("x must be either a flowSet or a GtaingSet object.")
  }

  # check mergeBy
  if (all(!mergeBy %in% c("all", colnames(pData(x))))) {
    stop("mergeBy should be the name of pData variables or 'all'.")
  }

  # Extract pData information
  pd <- pData(x)

  # Sort pd by mergeBy colnames
  if (!is.null(mergeBy)) {
    if (mergeBy[1] != "all") {
      pd <- pd[do.call("order", pd[mergeBy]), ]
    }
  }

  # flowSet for merging
  if (inherits(x, "GatingSet")) {
    fs <- getData(x, parent)
  } else {
    fs <- x
  }

  # merge all samples
  if (length(mergeBy) == 1 & mergeBy[1] == "all") {
    pd$merge <- rep("all", length(x))

    fr <- as(fs, "flowFrame")

    if ("Original" %in% BiocGenerics::colnames(fr)) {
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
    }

    if (!is.null(subSample)) {
      fr <- Subset(fr, sampleFilter(size = subSample))
    }

    fr.lst <- list(fr)

    # merge by one variable
  } else if (length(mergeBy) == 1) {
    pd$merge <- pd[, mergeBy]

    fr.lst <- lapply(unique(pd$merge), function(x) {
      fr <- as(fs[pd$name][pd$merge == x], "flowFrame")

      if ("Original" %in% BiocGenerics::colnames(fr)) {
        fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      }

      if (!is.null(subSample)) {
        fr <- Subset(fr, sampleFilter(size = subSample))
      }

      return(fr)
    })

    # merge by multiple variables
  } else {
    pd$merge <- do.call("paste", pd[, mergeBy])

    fr.lst <- lapply(unique(pd$merge), function(x) {
      fr <- as(fs[pd$name][pd$merge == x], "flowFrame")

      if ("Original" %in% BiocGenerics::colnames(fr)) {
        fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      }

      if (!is.null(subSample)) {
        fr <- Subset(fr, sampleFilter(size = subSample))
      }

      return(fr)
    })
  }
  names(fr.lst) <- unique(pd$merge)

  return(fr.lst)
}

#' Set plot margins
#'
#' @param x flowFrame or flowSet object to be plotted (post merging).
#' @param overlay object return by checkOverlay.
#' @param legend logical indicating whether a legend should be included in the
#'   plot.
#' @param text.legend text to be used in the legend, used to calculate required
#'   space.
#' @param main if NULL remove excess space above plot.
#'
#' @noRd
.setPlotMargins <- function(x, overlay = NULL, legend = NULL, text.legend = NULL, main = NULL) {

  # plot margins
  if (!is.null(overlay) & legend == TRUE) {
    mrgn <- 7 + max(nchar(text.legend)) * 0.32

    # Remove excess sapce above if no main
    if (is.null(main)) {
      par(mar = c(5, 5, 2, mrgn) + 0.1)
    } else {
      par(mar = c(5, 5, 4, mrgn) + 0.1)
    }
  } else {

    # Remove excess space above if no main
    if (is.null(main)) {
      par(mar = c(5, 5, 2, 2) + 0.1)
    } else {
      par(mar = c(5, 5, 4, 2) + 0.1)
    }
  }
}

#' Set plot layout
#'
#' @param x object to be plotted.
#' @param mfrow grid dimensions c(nr, nc), NULL or FALSE.
#' @param stack number of samples to include in a plot.
#'
#' @noRd
.setPlotLayout <- function(x, mfrow = NULL, stack = c(0, 1)) {

  # Number of samples
  smp <- length(x)

  # Stackig
  if (stack[1] != 0) {
    if (length(stack) == 1) {
      smp <- ceiling(smp / smp)
    } else {
      smp <- ceiling(smp / stack[2])
    }
  }

  # Plot layout
  if (is.null(mfrow)) {
    if (smp > 1) {
      mfrw <- c(grDevices::n2mfrow(smp)[2], grDevices::n2mfrow(smp)[1])
      par(mfrow = mfrw)
    } else {
      mfrw <- c(1, 1)
      par(mfrow = mfrw)
    }
  } else if (!is.null(mfrow)) {
    if (mfrow[1] == FALSE) {

      # Do nothing
    } else {
      par(mfrow = mfrow)
    }
  }

  if (is.null(mfrow)) {
    return(mfrw)
  } else if (mfrow[1] == FALSE) {
    return(FALSE)
  } else {
    return(mfrow)
  }
}

#' Gate 1D with overlays
#'
#' @param x flowFrame (base).
#' @param channel used in the plot.
#' @param overlay list of flowFrames to overlay.
#' @param gates gate object(s).
#' @param offset degree of stacking.
#' @param ... additional arguments passed to plotLabels.
#'
#' @noRd
.gateOverlay <- function(x, channel = NULL, overlay = NULL, gates = NULL, offset = NULL, alias = NA, format.text = NULL, font.text = 2, col.text = "black", cex.text = 0.8, alpha = 0.6, ...) {
  if (!inherits(x, "flowFrame")) {
    stop("x should be a flowFrame object.")
  }

  # Samples
  smp <- length(overlay) + 1

  # checkChannel
  channel <- checkChannels(x = x, channels = channel, plot = TRUE)

  # list of gates
  if (inherits(gates, "filters")) {

    # Convert to list of gates
    gates <- lapply(1:length(gates), function(gate) gates[[gate]])

    # Must be rectangleGates for 1D plots
    if (!all(as.vector(sapply(gates, class)) == "rectangleGate")) {
      stop("Only rectangleGate gates are supported in 1-D plots.")
    }
  } else if (inherits(gates, "list")) {

    # Must be rectangleGates for 1D plots
    if (!all(as.vector(sapply(gates, class)) == "rectangleGate")) {
      stop("Only rectangleGate gates are supported in 1-D plots.")
    }
  } else if (inherits(gates, "rectangleGate")) {
    gates <- list(gates)
  } else {
    stop("Supplied gate(s) should be of class filters, list or rectangleGate.")
  }

  # rectangleGates should be in 1D only
  if (any(lapply(gates, function(x) length(flowCore::parameters(x))) == 2)) {

    # Some gates are in 2D - construct 1D gate
    ind <- unname(which(lapply(gates, function(x) length(flowCore::parameters(x))) == 2))

    # Convert these gates to 1D gates
    gts <- lapply(ind, function(x) {

      # Extract gate for channel
      gates[[x]][channel]
    })
    gates[ind] <- gts
  }

  # Find center x co-ord for label position in each gate
  txt.x <- lapply(gates, function(x) {
    (unname(x@min) + unname(x@max)) / 2
  })

  # Find y co-ord for each sample
  txt.y <- sapply(1:smp, function(x) {
    (0.5 * offset * 100) + ((x - 1) * offset * 100)
  })

  # Plot gates
  plotGates(gates, channels = channel)

  # List of flowFrames for plotLabels
  fr.lst <- c(list(x), overlay)

  # Plot labels
  lapply(1:length(gates), function(x) {
    lapply(1:length(fr.lst), function(y) {
      plotLabels(x = fr.lst[[y]], channels = channel, gates = gates[[x]], x.text = txt.x[[x]], y.text = txt.y[y], alias = alias, format.text = format.text, font.text = font.text, col.text = col.text, cex.text = cex.text, alpha = alpha)
    })
  })
}

#' Get kernel density for a list of flowFrames
#' @noRd
.getDensity <- function(x, channel, adjust = 1.5, modal = TRUE, offset = 0){
  
  # x object of incorrect class
  if(!all(as.vector(sapply(x, class)) %in% "flowFrame")){
    stop("x should be a list of flowFrame objects.")
  }
  
  # Number of overlays
  ovn <- length(x) - 1
  
  # Get vector of offset values
  ofst <- seq(0, ovn * offset * 100, offset * 100)
  
  # Get a list of kernel densities
  frs.dens <- mapply(function(fr, ofst) {
    
    # Extract data
    fr.exprs <- flowCore::exprs(fr)[, channel]
    
    # Calculate kernel density
    fr.dens <- density(fr.exprs, adjust = adjust)
    
    # Normalise to mode
    if (length(x) != 1) {
      fr.dens$y <- (fr.dens$y / max(fr.dens$y)) * 100
    }else if(length(x) == 1 & modal == TRUE){
      fr.dens$y <- (fr.dens$y / max(fr.dens$y)) * 100
    }
    
    # Adjust values for stacking
    if(ofst != 0){
      fr.dens$y <- fr.dens$y + ofst
    }
    
    return(fr.dens)
    
  }, x, ofst, SIMPLIFY = FALSE)
  
  return(frs.dens)
}