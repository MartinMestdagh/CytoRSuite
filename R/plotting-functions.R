#' Boxed Labels - Modified plotrix
#' 
#' @param x,y  x and y position of the centers of the labels. \code{x} can be a xy.coords list.
#' @param bg The fill color of the rectangles on which the labels are displayed (see Details).
#' @param labels Text strings.
#' @param border Whether to draw borders around the rectangles.
#' @param xpad,ypad The proportion of the rectangles to the extent of the text within.
#' @param srt Rotation of the labels. if 90 or 270 degrees, the box will be rotated 90 degrees.
#' @param cex Character expansion. See \code{text}.
#' @param adj left/right adjustment. If this is set outside the function, the box will not be aligned properly.
#' @param xlog Whether the X axis is a log axis.
#' @param ylog Whether the y axis is a log axis.
#' @param alpha.bg Numeric [0,1] controlling the transparency of the background, set to 0.5 by default.
#' @param ... additional arguments passed to \code{text}.
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#' 
#' @importFrom graphics par strwidth strheight rect text
#' @importFrom grDevices col2rgb adjustcolor
#' @importFrom utils modifyList
#' 
#' @noRd
boxed.labels <- function(x, y = NA, labels,
                         bg = ifelse(match(par("bg"), "transparent", 0), "white", par("bg")),
                         border = NA, xpad = 1.2, ypad = 1.2, 
                         srt = 0, cex = 1, adj = 0.5, xlog = FALSE, ylog = FALSE, alpha.bg = 0.5, ...) {
  
  border <- NA
  oldpars <- par(c("cex", "xpd"))
  par(cex = cex, xpd = TRUE)
  if (is.na(y) && is.list(x)) {
    y <- unlist(x[[2]])
    x <- unlist(x[[1]])
  }
  box.adj <- adj + (xpad - 1) * cex * (0.5 - adj)
  if (srt == 90 || srt == 270) {
    bheights <- strwidth(labels)
    theights <- bheights * (1 - box.adj)
    bheights <- bheights * box.adj
    lwidths <- rwidths <- strheight(labels) * 0.5
  }
  else {
    lwidths <- strwidth(labels)
    rwidths <- lwidths * (1 - box.adj)
    lwidths <- lwidths * box.adj
    bheights <- theights <- strheight(labels) * 0.5
  }
  args <- list(x = x, y = y, labels = labels, srt = srt, adj = adj, 
               col = ifelse(colSums(col2rgb(bg) * c(1, 1.4, 0.6)) < 
                              350, "white", "black"))
  args <- modifyList(args, list(...))
  if(xlog){
    xpad<-xpad*2
    xr<-exp(log(x) - lwidths * xpad)
    xl<-exp(log(x) + lwidths * xpad)
  }
  else{
    xr<-x - lwidths * xpad
    xl<-x + lwidths * xpad
  }
  if(ylog){
    ypad<-ypad*2
    yb<-exp(log(y) - bheights * ypad)
    yt<-exp(log(y) + theights * ypad)
  }
  else{
    yb<-y - bheights * ypad
    yt<-y + theights * ypad
  }	
  rect(xr, yb, xl, yt, col = adjustcolor(col = bg, alpha.f = alpha.bg), border = border)
  do.call(text, args)
  par(cex = oldpars)
}

#' Get Appropriate Axes Labels for Transformed Channels - flowWorkspace
#' 
#' @param x object of class \code{flowFrame} or \code{GatingHierarchy}.
#' @param ... additional arguments.
#' 
#' @return list containing axis labels and breaks.
#' 
#' @export
setGeneric(name = "axisLabels",
           def = function(x, ...){standardGeneric("axisLabels")}
)

#' Get Appropriate Axes Labels for Transformed Channels - flowFrame Method
#'
#' @param x an object of class \code{flowFrame}.
#' @param channel name of the channel.
#' @param transList object of class \code{"transformList"} or
#'   \code{"transformerList"} generated by estimateLogicle containing the
#'   transformations applied to the flowFrame.
#'
#' @return list containing axis labels and breaks.
#'
#' @importFrom flowCore transformList inverseLogicleTransform
#'
#' @export
setMethod(axisLabels, signature = "flowFrame", definition = function(x, channel, transList){
  
  if(is.null(transList) | !class(transList)[1] %in%  c("transformList","transformerList")){
    
    stop("Please supply a valid transformList containing the transformations applied to the flowFrame.")
    
  }
  
  if(class(transList)[1] == "transformerList"){
    
    trns <- lapply(transList, `[[`, "transform")
    transList <- transformList(names(trns), trns)
    
  }
  
  if(!channel %in% names(transList@transforms)){
    
    # Channel not listed in trans object
    return(NULL)
    
  }
  
  fr <- x
  
  # Range of values
  r <- as.vector(range(fr)[,channel])

  # Transformation Functions & Breaks
  trans.func <- transList@transforms[[channel]]@f
  inv.func <- inverseLogicleTransform(transList)@transforms[[channel]]@f
  raw <- inv.func(r)
  brks <- flowBreaks(raw, n = 5, equal.space = FALSE)

  
  pos <- signif(trans.func(brks))
  label <- .pretty10exp(brks, drop.1 = TRUE)
  
  res <- list(label = label, at = pos)
  
  return(res)

})

#' Get Appropriate Axes Labels for Transformed Channels - GatingHierarchy Method
#'
#' @param x \code{GatingHiearchy}.
#' @param channel \code{character} channel name.
#'
#' @return when there is transformation function associated with the given
#'   channel, it returns a list of that contains positions and labels to draw on
#'   the axis otherwise returns NULL.
#'
#' @export
setMethod(axisLabels, signature = "GatingHierarchy", definition = function(x, channel){
  
  gh <- x
  res <- gh@axis[[sampleNames(gh)]][[channel]] #this call is to be deprecated once we figure out how to preserve trans when cloning GatingSet
  if(is.null(res)){
    #try to grab trans and do inverse trans for axis label on the fly
    trans <- getTransformations(gh, channel, only.function = FALSE)
    if(is.null(trans)){
      res <- NULL
    }else{
      inv.func <- trans[["inverse"]]
      trans.func <- trans[["transform"]]
      brk.func <- trans[["breaks"]]
      
      fr <- getData(gh, use.exprs = FALSE)
      r <- as.vector(range(fr)[,channel])#range
      raw <- inv.func(r)
      brks <- brk.func(raw)
      pos <- signif(trans.func(brks))
      #format it
      label <- trans[["format"]](brks)
      
      res <- list(label = label, at = pos)
    }
    
  }else{
    #use the stored axis label if exists
    res$label <- .pretty10exp(as.numeric(res$label),drop.1=TRUE)
  }
  
  return(res)
})

#' Generate the breaks that makes sense for flow data visualization - flowWorkspace
#'
#' It is mainly used as helper function to construct breaks function used by 'trans_new'.
#'
#' @return either 10^n intervals or equal-spaced(after transformed) intervals in raw scale.
#' @param n desired number of breaks (the actual number will be different depending on the data range)
#' @param x the raw data values
#' @param equal.space whether breaks at equal-spaced intervals
#' @param trans.fun the transform function (only needed when equal.space is TRUE)
#' @param inverse.fun the inverse function (only needed when equal.space is TRUE)
#' 
#' @noRd
flowBreaks <- function(x, n = 6, equal.space = FALSE, trans.fun, inverse.fun){
  
  rng.raw <- range(x, na.rm = TRUE)
  if(equal.space){
    
    rng <- trans.fun(rng.raw)
    min <- floor(rng[1])
    max <- ceiling(rng[2])
    if (max == min)
      return(inverse.fun(min))
    by <- (max - min)/(n-1)
    
    myBreaks <- inverse.fun(seq(min, max, by = by))
    
  }else{
    #log10 (e.g. 0, 10, 1000, ...)
    base10raw <- unlist(lapply(2:n,function(e)10^e))
    base10raw <- c(0,base10raw)
    myBreaks <- base10raw[base10raw > rng.raw[1] & base10raw < rng.raw[2]]
    
  }
  
  myBreaks
  
}

# copy from sfsmisc/flowWorkspace package
# modified to handle NA values
.pretty10exp <- function (x, drop.1 = FALSE, digits.fuzz = 7){
  
  eT <- floor(log10(abs(x)) + 10^-digits.fuzz)
  mT <- signif(x/10^eT, digits.fuzz)
  ss <- vector("list", length(x))
  
  for (i in seq(along = x)) ss[[i]] <- if (is.na(x[i]))
    quote(NA)
  else if (x[i] == 0)
    quote(0)
  else if (drop.1 && mT[i] == 1)
    substitute(10^E, list(E = eT[i]))
  else if (drop.1 && mT[i] == -1)
    substitute(-10^E, list(E = eT[i]))
  else substitute(A %*% 10^E, list(A = mT[i], E = eT[i]))
  
  do.call("expression", ss)
  
}

#' Get Axes Limits
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param parent name of the parental node to extract from GatingHierarchy or
#'   GatingSet.
#' @param channels name of the channels or markers to be used to construct the
#'   plot.
#' @param overlay a \code{flowFrame}, \code{flowSet}, \code{list of flowFrames},
#'   \code{list of flowSets} or \code{list of flowFrame lists} containing
#'   populations to be overlayed onto the plot(s). Data for overlays will be
#'   merged with \code{x} prior to axis limit calculation to ensure that the
#'   axes limits are set based on all the data to be included in the plot.
#' @param limits indicates whether the limits of the "data" or limits of the
#'   "machine" should be returned. This argument will only influence the upper
#'   limit. The lower limit will always be set to 0, unless the data contains
#'   values below this limit. In such cases the lower limit of the data will be
#'   used instead. This argument is set to "machine" by default.
#'
#' @importFrom flowCore exprs flowSet parameters
#' @importFrom flowWorkspace pData
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.getAxesLimits <- function(x, parent = "root", channels, overlay = NULL, limits = "machine"){
  
  # Missing channels
  if(missing(channels)){
    
    stop("Please supply the names of the channel(s) to calculate axes limits.")
    
  }else{

    channels <- checkChannels(x = x, channels = channels, plot = FALSE)
    
  }
  
  # Incorrect limits argument
  if(!limits %in% c("data","machine")){
    
    stop("Limits argument should be either 'data' or 'machine'.")
    
  }
  
  # x is a flowFrame
  if(inherits(x, "flowFrame")){
    
    fr <- x
    
  # x is a flowSet
  }else if(inherits(x, "flowSet")){
    
    fr <- as(x, "flowFrame")
    
    if("Original" %in% BiocGenerics::colnames(fr)){
      
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      
    }
    
  # x is a GatingHierarchy  
  }else if(inherits(x, "GatingHierarchy")){
    
    fr <- getData(x, parent)
    
  # x is a GatingSet  
  }else if(inherits(x, "GatingSet")){
    
    fr <- as(getData(x, parent), "flowFrame")
    
    if("Original" %in% BiocGenerics::colnames(fr)){
      
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      
    }
    
  }
  
  # Extract summary stats
  sm <- pData(parameters(fr))
  
  lms <- lapply(channels, function(channel){
    
    # Extract machine limits
    mlms <- vector()
    mlms[1] <- sm[sm$name == channel, "minRange"]
    mlms[2] <- sm[sm$name == channel, "maxRange"]
    
    if(mlms[1] > 0){
        
      mlms <- c(0, mlms[2])
      
    }
    
    # Add 10% buffer on lower limit
    rng <- 0.1*(mlms[2] - mlms[1])
    mlms <- c(mlms[1]- rng, mlms[2])
    
    # Machine limits
    if(limits == "machine"){

      lms <- mlms
    
    # Data limits
    }else if(limits == "data"){
    
      # No overlay
      if(is.null(overlay)){
    
       # overlay
      }else if(!is.null(overlay)){
    
         # Get merged flowFrame to calculate axes limits
         # flowFrame
         if(class(overlay) == "flowFrame"){
      
          fr <- as(flowSet(list(fr,overlay)),"flowFrame")
      
         # flowSet  
         }else if(class(overlay) == "flowSet"){
      
           ov <- as(overlay, "flowFrame")
      
           if(is.na(match("Original", BiocGenerics::colnames(ov))) == FALSE){
        
               ov <- ov[, -match("Original", BiocGenerics::colnames(ov))]
          
           }
           fr <- as(flowSet(list(fr,ov)),"flowFrame")
      
         # list 
         }else if(class(overlay) == "list"){
      
           # list of flowFrames
          if(all(as.vector(sapply(overlay, function(x) {class(x)})) == "flowFrame"))
      
            fr <- as(flowSet(c(list(fr),overlay)),"flowFrame")
        
           # list of flowSets
           }else if(all(as.vector(sapply(overlay, function(x) {class(x)})) == "flowFrame")){
       
             ov <- lapply(overlay, function(x){as(x,"flowFrame")})
        
            if(is.na(match("Original", BiocGenerics::colnames(ov[[1]]))) == FALSE){
          
               ov <- lapply(ov,function(fr){
            
                 fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]
            
                 return(fr)
            
               })
        
             }
             fr <- as(flowSet(c(list(fr), ov)),"flowFrame")
        
           # list of lists   
           }else if(all(as.vector(sapply(overlay, function(x) {class(x)})) == "list")){
        
             # flowFrame lists
             if(all(as.vector(sapply(overlay, function(x) {sapply(x,class)})) == "flowFrame")){
          
               fr.lst <- lapply(overlay, function(x){
            
                as(flowSet(x),"flowFrame")
            
               })
          
               if(is.na(match("Original", BiocGenerics::colnames(fr.lst[[1]]))) == FALSE){
            
                 ov <- lapply(fr.lst,function(fr){
              
                   fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]
              
                   return(fr)
              
                 })
            
               }
               fr <- as(flowSet(c(list(fr),ov)),"flowFrame")
          
             }
        
              # flowSet lists
             if(all(as.vector(sapply(overlay, function(x) {sapply(x,class)})) == "flowSet")){
          
               fr.lst <- lapply(overlay, function(x){
            
                 as(x,"flowFrame")
            
               })
          
               if(is.na(match("Original", BiocGenerics::colnames(fr.lst[[1]]))) == FALSE){
            
                 ov <- lapply(fr.lst,function(fr){
              
                   fr <- fr[, -match("Original", BiocGenerics::colnames(fr))]
              
                   return(fr)
              
                  })
          
               fr <- as(flowSet(c(list(fr),ov)),"flowFrame")
          
               }
          
            }
    
         }
    
       }
  
     # Limits from flowFrame
     lms <- range(exprs(fr)[,channel])
     lms <- c(mlms[1], lms[2] + (0.1*(lms[2] - mlms[1])))
    
    }
    
    return(lms)
    
  })
  
  names(lms) <- channels
  
  return(lms)

}

#' Merge overlay for merged data
#'
#' @param x flowSet data to be merged.
#' @param overlay object generated by checkOverlay flowSet method (list of
#'   flowFrame lists).
#' @param mergeBy pData variables of x used to merge the data. To merge all
#'   samples set mergeBy to "all".
#' @param subSample numeric indicating the number of events to include.
#'
#' @noRd
.mergeOverlay <- function(x, overlay, mergeBy = "all", subSample = NULL){
  
  # x is flowSet prior to merging
  if(!class(x)[1] %in% c("flowSet","GatingSet") | length(overlay) != length(x)){
    
    stop("Supply the original data prior to merging.")
    
  }
  
  # Extract pData
  pd <- pData(x)
  
  # Sort pd by mergeBy colnames
  if(mergeBy != "all"){
      
    pd <- pd[do.call("order", pd[mergeBy]), ]
      
  }
  
  # Find new indicies
  ind <- match(sampleNames(fs), pd$name)
    
  # Reorder overlays based on merge levels
  overlay <- overlay[ind]
  
  # List of group indicies - ind
  if(length(mergeBy) == 1 & mergeBy[1] == "all"){
    
    grps <- list(1:length(x))
    
  }else{
    
    # Groups
    if(length(mergeBy) == 1){
      
      pd$mrg <- pd[, mergeBy]
      
    }else{
      
      pd$mrg <- do.call("paste", pd[, mergeBy])
      
    }
    
    # Get a list of indices per group
    grps <- lapply(unique(pd$mrg), function(x){
      
      which(pd$mrg == x)
      
    })
    
  }
  
  # Subset overlay, merge & subSample
  overlay <- lapply(grps, function(x){
      
    ov <- overlay[x]
    
    lapply(seq(1,length(ov[[1]]),1), function(x){
        
      fr.lst <- lapply(ov, `[[`, x)
      
      # if same flowFrame return first only
      if(length(unique(fr.lst)) == 1 | length(unique(sapply(fr.lst, function(x){x@description$GUID}))) == 1){
        
        fr <- fr.lst[[1]]
        
      }else{
      
        fs <- flowSet(fr.lst)
      
        fr <- as(fs, "flowFrame")
        
        if("Original" %in% BiocGenerics::colnames(fr)){
        
          fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
          
        }
        
      }
      
      if(!is.null(subSample)){
          
        fr <- Subset(fr, sampleFilter(size = subSample))
          
      }
      
      return(fr)
        
    })
      
  })
  
  return(overlay)
  
}

#' Merge samples by pData
#'
#' @param x flowSet or GatingSet object
#' @param parent name of the parent population to extract from GatingSet object.
#' @param mergeBy names of pData variables to use for merging. Set to "all" to
#'   merge all samples in the flowSet.
#' @param subSample number of events to include in each group.
#'   
#' @return list containing merged flowFrames, named with group.
#'
#' @noRd
.mergeBy <- function(x, parent = "root", mergeBy = "all", subSample = NULL){
  
  # check x
  if(inherits(x, "flowFrame") | inherits(x, "GatingHierarchy")){
    
    stop("x must be either a flowSet or a GtaingSet object.")
    
  }
  
  # check mergeBy
  if(all(!mergeBy %in% c("all", colnames(pData(x))))){
    
    stop("mergeBy should be the name of pData variables or 'all'.")
    
  }
  
  # Extract pData information
  pd <- pData(x)
  
  # Sort pd by mergeBy colnames
  if(!is.null(mergeBy)){
    
    if(mergeBy != "all"){
      
      pd <- pd[do.call("order", pd[mergeBy]), ]
      
    }
    
  }
  
  # flowSet for merging
  if(inherits(x, "GatingSet")){
    
    fs <- getData(x, parent)
    
  }else{
    
    fs <- x
    
  }
  
  # merge all samples
  if(length(mergeBy) == 1 & mergeBy[1] == "all"){
    
    pd$merge <- rep("all", length(x))
    
    fr <- as(fs, "flowFrame")
    
    if("Original" %in% BiocGenerics::colnames(fr)){
      
      fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
      
    }
    
    if(!is.null(subSample)){
      
      fr <- Subset(fr, sampleFilter(size = subSample))
      
    }
    
    fr.lst <- list(fr)
    
  # merge by one variable
  }else if(length(mergeBy) == 1){
    
    pd$merge <- pd[, mergeBy]
    
    fr.lst <- lapply(unique(pd$merge), function(x){
      
      fr <- as(fs[pd$name][pd$merge == x], "flowFrame")
      
      if("Original" %in% BiocGenerics::colnames(fr)){
        
        fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
        
      }
      
      if(!is.null(subSample)){
        
        fr <- Subset(fr, sampleFilter(size = subSample))
        
      }
      
      return(fr)
      
    })
    
  # merge by multiple variables  
  }else{
    
    pd$merge <- do.call("paste", pd[, mergeBy])
    
    fr.lst <- lapply(unique(pd$merge), function(x){
      
      fr <- as(fs[pd$name][pd$merge == x], "flowFrame")
      
      if("Original" %in% BiocGenerics::colnames(fr)){
        
        fr <- suppressWarnings(fr[, -match("Original", BiocGenerics::colnames(fr))])
        
      }
      
      if(!is.null(subSample)){
        
        fr <- Subset(fr, sampleFilter(size = subSample))
        
      }
      
      return(fr)
      
    })
    
  }
  names(fr.lst) <- unique(pd$merge)
  
  return(fr.lst)
  
}

#' Set plot margins
#'
#' @param x flowFrame or flowSet object to be plotted (post merging).
#' @param overlay object return by checkOverlay.
#' @param legend logical indicating whether a legend should be included in the
#'   plot.
#' @param text.legend text to be used in the legend, used to calculate required
#'   space.
#' @param main if NULL remove excess space above plot.
#'
#' @noRd
.setPlotMargins <- function(x, overlay = NULL, legend = NULL, text.legend = NULL, main = NULL){
      
  # plot margins
  if(!is.null(overlay) & legend == TRUE){
          
    mrgn <- 7 + max(nchar(text.legend))*0.32
        
    # Remove excess sapce above if no main  
    if(is.null(main)){
          
      par(mar = c(5, 5, 2, mrgn) + 0.1)
          
    }else{
        
      par(mar = c(5, 5, 4, mrgn) + 0.1)
        
    }
        
  }else{
        
    # Remove excess space above if no main
    if(is.null(main)){
          
      par(mar = c(5, 5, 2, 2) + 0.1)
          
    }else{
          
      par(mar = c(5, 5, 4, 2) + 0.1)
          
    }
        
  }
    
}

#' Set plot layout
#' 
#' @param x object to be plotted.
#' @param mfrow grid dimensions c(nr, nc), NULL or FALSE.
#' @param stack number of samples to include in a plot.
#' 
#' @noRd
.setPlotLayout <- function(x, mfrow = NULL, stack = c(0,1)){
  
  # Number of samples
  smp <- length(x)
  
  # Stackig
  if(stack[1] != 0){
    
    if(length(stack) == 1){
      smp <- ceiling(smp/smp)
    }else{
      smp <- ceiling(smp/stack[2])
    }
    
  }
  
  # Plot layout
  if(is.null(mfrow)){
    
    if(smp > 1){
      mfrw <- c(grDevices::n2mfrow(smp)[2], grDevices::n2mfrow(smp)[1])
      par(mfrow = mfrw)
    }else{
      mfrw <- c(1,1)
      par(mfrow = mfrw)
    }
    
  }else if(!is.null(mfrow)){
    
    if(mfrow[1] == FALSE){
      
      # Do nothing
      
    }else{
      
      par(mfrow = mfrow)
      
    }
    
  }
  
  if(is.null(mfrow)){
    return(mfrw)
  }else if(mfrow[1] == FALSE){
    return(FALSE)
  }else{
    return(mfrow)
  }

}

#' Gate 1D with overlays
#'
#' @param x flowFrame (base).
#' @param channel used in the plot.
#' @param overlay list of flowFrames to overlay.
#' @param gates gate object(s).
#' @param offset degree of stacking.
#' @param ... additional arguments passed to plotLabels.
#' 
#' @noRd
.gateOverlay <- function(x, channel = NULL, overlay = NULL, gates = NULL, offset = NULL, alias = NA, format.text = NULL, font.text = 2, col.text = "black", cex.text = 0.8, alpha = 0.6, ...){
  
  if(!inherits(x, "flowFrame")){
    
    stop("x should be a flowFrame object.")
    
  }
  
  # Samples
  smp <- length(overlay) + 1
  
  # checkChannel
  channel <- checkChannels(x = x, channels = channel, plot = TRUE)
  
  # list of gates
  if(inherits(gates, "filters")){
    
    # Convert to list of gates
    gates <- lapply(1:length(gates), function(gate) gates[[gate]])
    
    # Must be rectangleGates for 1D plots
    if(!all(as.vector(sapply(gates, class)) == "rectangleGate")){
      
      stop("Only rectangleGate gates are supported in 1-D plots.")
      
    }
    
  }else if(inherits(gates, "list")){
    
    # Must be rectangleGates for 1D plots
    if(!all(as.vector(sapply(gates, class)) == "rectangleGate")){
      
      stop("Only rectangleGate gates are supported in 1-D plots.")
      
    }
    
  }else if(inherits(gates, "rectangleGate")){
    
    gates <- list(gates)
    
  }else{
    
    stop("Supplied gate(s) should be of class filters, list or rectangleGate.")
    
  }
  
  # rectangleGates should be in 1D only
  if(any(lapply(gates, function(x) length(flowCore::parameters(x))) == 2)){
        
     # Some gates are in 2D - construct 1D gate
     ind <- unname(which(lapply(gates, function(x) length(flowCore::parameters(x))) == 2))
        
     # Convert these gates to 1D gates
     gts <- lapply(ind, function(x){
          
       # Extract gate for channel
       gates[[x]][channel]
          
     })
     gates[ind] <- gts
        
  }
  
  # Find center x co-ord for label position in each gate
  txt.x <- lapply(gates, function(x){
    
    (unname(x@min) + unname(x@max))/2
    
  })
  
  # Find y co-ord for each sample
  txt.y <- sapply(1:smp, function(x){
    
    (0.5*offset*100) + ((x-1)*offset*100)
    
  })
  
  # Plot gates
  plotGates(gates, channels = channel)
  
  # List of flowFrames for plotLabels
  fr.lst <- c(list(x), overlay)

  # Plot labels
  lapply(1:length(gates), function(x){
    
    lapply(1:length(fr.lst), function(y){
      
      plotLabels(x = fr.lst[[y]], channels = channel, gates = gates[[x]], x.text = txt.x[[x]], y.text = txt.y[y], alias = alias, format.text = format.text, font.text = font.text, col.text = col.text, cex.text = cex.text, alpha = alpha)
      
    })
    
  })
  
}