#' Compute Spillover Matrix
#'
#' \code{computeSpillover} uses the method described by Bagwell & Adams 1993 to
#' calculate the fluorescent spillover matrix using a reference universal
#' unstained control and single stain compensation controls.
#'
#' \code{computeSpillover} begins by the user selecting which fluorescent
#' channel is associated with each control from a dropdown menu. Following
#' channel selection, \code{computeSpillover} runs through each control and
#' plots the density distribution of the unstained control in red and the
#' compensation control in blue. Users can then gate the positive signal for
#' spillover calculation using an interval gate. The percentage spillover is
#' calculated based on the median fluorescent intensities of the stained
#' populations and the universal unstained sample. The computed spillover matrix
#' is returned as an r object and written to a named .csv file for future use.
#' \code{computeSpillover} has methods for both
#' \code{\link[flowCore:flowSet-class]{flowSet}} and
#' \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} objects so refer to
#' their respective help pages for more information.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}}.
#' @param ... additional method-specific arguments for computeSpillover.
#'
#' @seealso \code{\link{computeSpillover,flowSet-method}}
#' @seealso \code{\link{computeSpillover,GatingSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @references C. B. Bagwell \& E. G. Adams (1993). Fluorescence spectral
#'   overlap compensation for any number of flow cytometry parameters. in:
#'   Annals of the New York Academy of Sciences, 677:167-184.
#'
#' @export
setGeneric(
  name = "computeSpillover",
  def = function(x, ...) {
    standardGeneric("computeSpillover")
  }
)

#' Compute Spillover Matrix - flowSet Method
#'
#' \code{computeSpillover} uses the method described by Bagwell & Adams 1993 to
#' calculate the fluorescent spillover matrix using a reference universal
#' unstained control and single stain compensation controls.
#'
#' Calculate spillover matrix using
#' \code{\link[flowCore:flowSet-class]{flowSet}} containing gated single stain
#' compensation controls and an unstained control. \code{computeSpillover}
#' begins by the user selecting which fluorescent channel is associated with
#' each control from a dropdown menu. Following channel selection,
#' \code{computeSpillover} runs through each control and plots the density
#' distribution of the unstained control in red and the compensation control in
#' blue. Users can then gate the positive signal for spillover calculation using
#' an interval gate. The percentage spillover is calculated based on the median
#' fluorescent intensities of the stained populations and the universal
#' unstained sample. The computed spillover matrix is returned as an r object
#' and written to a named .csv file for future use.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}
#'   containing pre-gated single stain compensation controls and a universal
#'   unstained control. Currently, computeSpillover does not pre-gate samples to
#'   obtain a homogeneous cell population for downstream calculations. We
#'   therefore recommmend pre-gating samples based on FSC and SSC parameters
#'   prior to passing them to computeSpillover (i.e. \code{x} should contain
#'   events for single cells only). Passing raw files to computeSpillover will
#'   result in inaccurate calculations of fluorescent spillover matrix.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} generated by
#'   \code{estimateLogicle} to transform fluorescent channels for gating.
#'   \code{transList} is required if logicle transformation has already been
#'   applied to \code{x} using estimateLogicle. \code{computeSpillover} will
#'   automatically call \code{\link[flowCore:logicleTransform]{estimateLogicle}}
#'   internally to transform channels prior to gating, if \code{transList} is
#'   supplied it will be used for the transformation instead.
#' @param cmfile name of .csv file containing the names of the samples in a
#'   column called "name" and their matching channel in a column called
#'   "channel". \code{computeSpillover} will the guide you through the channel
#'   selection process and generate a channel match file called "Compensation
#'   Channels.csv" automatically. If you already have a complete cmfile and
#'   would like to bypass the channel selection process, simply pass the name of
#'   the cmfile to this argument (e.g. "Compensation Channels.csv").
#' @param spfile name of the output spillover csv file, set to \code{"Spillover
#'   Matrix.csv"} by default.
#' @param ... additional arguments passed to \code{\link{plotCyto1d,flowFrame-method}}
#' and \code{\link{plotCyto1d,flowSet-method}}.
#'
#' @return spillover matrix object and \code{"Spillover Matrix.csv"} file.
#'
#' @examples
#' \dontrun{
#' library(CytoRSuiteData)
#' 
#' # Use Compensation controls in CytoRSuiteData
#' fs <- Compensation
#' 
#' # Compute spillover matrix
#' spill <- computeSpillover(fs)
#' 
#' # Find 'Spillover Matrix.csv' and 'Compensation Channels.csv' in working directory.
#' 
#' # Apply spillover matrix
#' fs <- compensate(fs, spill)
#' }
#' 
#' @importFrom flowCore estimateLogicle transform each_col fsApply
#'   inverseLogicleTransform sampleNames flowSet
#' @importFrom flowWorkspace pData GatingSet
#' @importFrom methods as
#' @importFrom utils read.csv write.csv
#' @importFrom stats median
#'
#' @seealso \code{\link{plotCyto1d,flowFrame-method}}
#' @seealso \code{\link{plotCyto1d,flowSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @references C. B. Bagwell \& E. G. Adams (1993). Fluorescence spectral
#'   overlap compensation for any number of flow cytometry parameters. in:
#'   Annals of the New York Academy of Sciences, 677:167-184.
#'
#' @export
setMethod(computeSpillover, signature = "flowSet", definition = function(x, transList = NULL, cmfile = NULL, spfile = "Spillover Matrix.csv", ...) {

  # Assign x to fs
  fs <- x

  # Extract pData information
  pd <- pData(fs)

  # Extract fluorescent channels
  channels <- getChannels(fs)

  # Select a fluorescent channel for each compensation control
  if (is.null(cmfile)) {
    pd$channel <- paste(selectChannels(fs))
    write.csv(pd, "Compensation Channels.csv", row.names = FALSE)
  } else {
    cm <- read.csv(cmfile, header = TRUE, row.names = 1)
    chans <- cm$channel[match(sampleNames(fs), row.names(cm))]
    pd$channel <- paste(chans)
  }

  # Merge files for use with estimateLogicle
  fr <- as(fs, "flowFrame")

  # Extract summary statistics
  sm <- pData(parameters(fs[[1]]))

  # Get complete transformList object
  transList <- .getCompleteTransList(fr, transList = transList)

  # Get transformed data - all fluorescent channels transformed
  fs <- .getTransformedData(fs, transList = transList)

  # Extract unstained control based on selected channels in pData(fs)
  NIL <- fs[[match("Unstained", pd$channel)]]
  fs <- fs[-match("Unstained", pd$channel)]

  # Names
  nms <- sampleNames(fs)

  # Samples
  smp <- length(fs)

  # Remove NIL from pd
  pd <- pd[!pd$channel == "Unstained", ]

  # Gate positive populations
  pops <- lapply(seq(1, smp, 1), function(x) {

    # Extract flowFrame
    fr <- fs[[x]]

    # Channel
    chan <- pd$channel[x]

    # Plot
    plotCyto(NIL, channels = chan, overlay = fr, offset = 0, transList = transList, popup = TRUE, fill = c("red", "dodgerblue"), legend = FALSE, alpha = 0.6, main = nms[x], ...)

    # Call drawGate on each flowFrame using interval gate on selected channel
    if (getOption("CytoRSuite_interact") == TRUE) {
      gt <- drawGate(x = fr, alias = paste(chan, "+"), channels = chan, type = "interval", adjust = 1.5, plot = FALSE)
      fr <- Subset(fr, gt[[1]])
    }

    return(fr)
  })
  names(pops) <- nms
  pops <- flowSet(pops)

  # Inverse logicle transformation
  inv <- checkTransList(transList = transList, inverse = TRUE)
  pops <- suppressMessages(transform(pops, inv))
  NIL <- suppressMessages(transform(NIL, inv))

  # Calculate MedFI for all channels for unstained control
  neg <- each_col(NIL, median)[channels]

  # Calculate MedFI for all channels for all stained controls
  pos <- fsApply(pops, each_col, median)[, channels]

  # Subtract background fluorescence
  signal <- sweep(pos, 2, neg)

  # Construct spillover matrix - only include values for which there is a control
  spill <- diag(x = 1, nrow = length(channels), ncol = length(channels))
  colnames(spill) <- channels
  rownames(spill) <- channels

  # Normalise each row to stained channel
  lapply(seq(1, nrow(signal), 1), function(x) {
    signal[x, ] <<- signal[x, ] / signal[x, match(pd$channel[x], colnames(spill))]
  })

  # Insert values into appropriate rows
  rws <- match(pd$channel, rownames(spill))
  spill[rws, ] <- signal

  # write spillover matrix to csv file
  write.csv(spill, spfile)

  return(spill)
})

#' Compute Spillover Matrix - GatingSet Method
#'
#' \code{computeSpillover} uses the method described by Bagwell & Adams 1993 to
#' calculate the fluorescent spillover matrix using a reference universal
#' unstained control and single stain compensation controls.
#'
#' Calculate spillover matrix using
#' \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing gated
#' single stain compensation controls and an unstained control.
#' \code{computeSpillover} uses the method described by Bagwell & Adams 1993 to
#' calculate fluorescent spillover values using single stain compensation
#' controls and a universal unstained control. \code{computeSpillover} begins by
#' the user selecting which fluorescent channel is associated with each control
#' from a dropdown menu. Following channel selection, \code{computeSpillover}
#' runs through each control and plots the density distribution of the unstained
#' control in red and the compensation control in blue. Users can then gate the
#' positive signal for spillover calculation using an interval gate. The
#' percentage spillover is calculated based on the median fluorescent
#' intensities of the stained populations and the universal unstained sample.
#' The computed spillover matrix is returned as an r object and written to a
#' named .csv file for future use.
#'
#' @param x object of class
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing pre-gated
#'   single stain compensation controls and a universal unstained control.
#'   Currently, computeSpillover does not pre-gate samples to obtain a
#'   homogeneous cell population for downstream calculations. We therefore
#'   recommmend pre-gating samples based on FSC and SSC parameters prior to
#'   passing them to computeSpillover and indicate the population of interest
#'   using the \code{parent} argument.
#' @param parent name of the pre-gated population to use for downstream
#'   calculations, set to the last node of the GatingSet by default (e.g.
#'   "Single Cells").
#' @param transList object of class
#'   \code{\link[flowWorkspace:transformerList]{transformerList}} generated by
#'   \code{estimateLogicle} to transform fluorescent channels for gating.
#'   \code{transList} is required if logicle transformation has already been
#'   applied to \code{x} using estimateLogicle. \code{computeSpillover} will
#'   automatically call \code{\link[flowCore:logicleTransform]{estimateLogicle}}
#'   internally to transform channels prior to gating, if \code{transList} is
#'   supplied it will be used for the transformation instead.
#' @param cmfile name of .csv file containing the names of the samples in a
#'   column called "name" and their matching channel in a column called
#'   "channel". \code{computeSpillover} will the guide you through the channel
#'   selection process and generate a channel match file called "Compensation
#'   Channels.csv" automatically. If you already have a complete cmfile and
#'   would like to bypass the channel selection process, simply pass the name of
#'   the cmfile to this argument (e.g. "Compensation Channels.csv").
#' @param spfile name of the output spillover csv file, set to \code{"Spillover
#'   Matrix.csv"} by default.
#' @param ... additional arguments passed to \code{\link{plotCyto1d,flowFrame-method}}
#' and \code{\link{plotCyto1d,flowSet-method}}.
#'
#' @return spillover matrix object and \code{"Spillover Matrix.csv"} file.
#'
#' @examples
#' \dontrun{
#' library(CytoRSuiteData)
#' 
#' # Use Compensation controls in CytoRSuiteData
#' fs <- Compensation
#' 
#' # Add controls to GatingSet
#' gs <- GatingSet(fs)
#' 
#' # Gate controls using drawGate
#' drawGate(gs,
#'   parent = "root",
#'   alias = "Single Cells",
#'   channels = c("FSC-A", "FSC-H"),
#'   gtfile = "Compensation-gatingTemplate.csv"
#' )
#' 
#' # Find 'Compensation-gatingTemplate.csv' in working directory
#' 
#' # Compute spillover matrix
#' spill <- computeSpillover(gs, parent = "Single Cells")
#' 
#' # Find 'Spillover Matrix.csv' and 'Compensation Channels.csv' in working directory.
#' 
#' # Apply spillover matrix
#' gs <- compensate(gs, spill)
#' }
#' 
#' @importFrom flowCore estimateLogicle transform each_col fsApply
#'   inverseLogicleTransform flowSet
#' @importFrom flowWorkspace getData pData getTransformations GatingSet
#' @importFrom methods as
#'
#' @seealso \code{\link{plotCyto1d,flowFrame-method}}
#' @seealso \code{\link{plotCyto1d,flowSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @references C. B. Bagwell \& E. G. Adams (1993). Fluorescence spectral
#'   overlap compensation for any number of flow cytometry parameters. in:
#'   Annals of the New York Academy of Sciences, 677:167-184.
#'
#' @export
setMethod(computeSpillover, signature = "GatingSet", definition = function(x, parent = NULL, transList = NULL, cmfile = NULL, spfile = "Spillover Matrix.csv", ...) {
  gs <- x

  # Extract Population for Downstream Analyses
  if (!is.null(parent)) {
    fs <- getData(gs, parent)
  } else if (is.null(parent)) {
    fs <- getData(gs, getNodes(gs)[length(getNodes(gs))])
  }

  # Merge files for use with estimateLogicle
  fr <- as(fs, "flowFrame")
  fs.m <- flowSet(fr)
  gs.m <- suppressMessages(GatingSet(fs.m))

  # Extract fluorescent channels
  channels <- getChannels(gs)

  # Get complete transformerList
  transList <- .getCompleteTransList(gs, transList = transList)

  # Get complete transformList
  transList <- checkTransList(transList = transList, inverse = FALSE)

  computeSpillover(x = fs, transList = transList, cmfile = cmfile, spfile = spfile, ...)
})

#' .getCompleteTransList
#' return complete (all fluorescent channels) transList
#' for flowFrame, flowSet or GatingSet
#' @noRd
.getCompleteTransList <- function(x, transList = NULL) {

  # Check class of transList
  if (!is.null(transList)) {
    if (!any(inherits(transList, "transformList") | inherits(transList, "transformerList"))) {
      stop("Supplied transList should be of class transformList or transformerList.")
    }
  }

  # Extract fluorescent channels
  channels <- getChannels(x)

  # If NULL transList get all transformations
  if (is.null(transList)) {
    if (inherits(x, "flowFrame")) {
      if (.checkDataTransform(x) == TRUE) {
        stop("Looks like the data is already transformed. Please supply the transList used.")
      }

      transList <- flowCore::estimateLogicle(x, channels)
      return(transList)
    } else if (inherits(x, "flowSet")) {
      if (.checkDataTransform(x) == TRUE) {
        stop("Looks like the data is already transformed. Please supply the transList used.")
      }

      transList <- flowCore::estimateLogicle(as(x, "flowFrame"), channels)
      return(transList)
    } else if (inherits(x, "GatingSet")) {
      if (.checkDataTransform(x) == TRUE & length(x@transformation) == 0) {
        stop("Looks like the data is already transformed. No transformations found in GatingSet.")
      }

      # GatingSet is not transformed
      if (length(x@transformation) == 0) {

        # GatingSet is not transformed
        fs <- flowWorkspace::getData(x, "root")
        fr <- as(fs, "flowFrame")
        fs <- flowCore::flowSet(fr)
        gs <- suppressMessages(flowWorkspace::GatingSet(fs))

        transList <- flowCore::estimateLogicle(gs[[1]], channels)
        return(transList)

        # GatingSet contains transformations
      } else if (length(x@transformation) != 0) {
        chans <- names(x@transformation[[1]])

        if (any(chans %in% channels)) {

          # Extract transformations from GatingSet
          trnsfrms <- lapply(channels[chans %in% channels], function(channel) {
            getTransformations(x[[1]], channel, only.function = FALSE)
          })
          names(trnsfrms) <- channels[chans %in% channels]

          # Remove NULL transforms
          trnsfrms[sapply(trnsfrms, is.null)] <- NULL
          transList <- transformerList(names(trnsfrms), trnsfrms)

          if (all(channels %in% names(transList))) {

            # GatingSet contains all transformations
            return(transList)
          } else {

            # Get remaining transformations with estimateLogicle
            fs <- flowWorkspace::getData(x, "root")
            fr <- as(fs, "flowFrame")
            fs <- flowCore::flowSet(fr)
            gs <- suppressMessages(flowWorkspace::GatingSet(fs))

            trnsLst <- flowCore::estimateLogicle(gs[[1]], channels[!channels %in% names(transList)])
            transList <- c(trnsLst, transList)
            transList <- flowWorkspace::transformerList(names(transList), transList)

            return(transList)
          }
        } else {

          # GatingSet does not contain transformations for fluorescent channels
          fs <- flowWorkspace::getData(x, "root")
          fr <- as(fs, "flowFrame")
          fs <- flowCore::flowSet(fr)
          gs <- suppressMessages(flowWorkspace::GatingSet(fs))

          trnsLst <- flowCore::estimateLogicle(gs[[1]], channels)
          transList <- c(trnsLst, transList)
          transList <- flowWorkspace::transformerList(names(transList), transList)

          return(transList)
        }
      }
    }
  } else if (!is.null(transList)) {

    # flowFrame or flowSet return transformList
    if (inherits(x, "flowFrame") | inherits(x, "flowSet")) {

      # Run checkTransList to get transformList
      transList <- checkTransList(transList = transList, inverse = FALSE)

      # Check which channels have been transformed
      chans <- names(transList@transforms)

      # TransList contains transformations for all fluorescent channels
      if (all(channels %in% chans)) {

        # TransList is complete
        return(transList)

        # Some fluorescent channels don't have transformations
      } else {

        # Convert x to flowSet
        if (inherits(x, "flowFrame")) {
          fs <- flowCore::flowSet(x)
        } else if (inherits(x, "flowSet")) {
          fs <- x
        }

        # Generate merged flowFrame for use with estimateLogicle
        fr <- as(fs, "flowFrame")

        # Find channels excluded from transList
        excl <- channels[!channels %in% chans]

        # Get transformations for these channels using estimateLogicle
        trans <- flowCore::estimateLogicle(fr, excl)

        # Combine supplied transList with add transformations
        nms <- c(names(transList@transforms), excl)
        transList <- c(transList, trans)
        names(transList@transforms) <- nms

        return(transList)
      }

      # GatingSet return transformerList
    } else if (inherits(x, "GatingSet")) {

      # Supplied transList is a transformList - convert to transformerList
      if (inherits(transList, "transformList")) {

        # Get transform functions
        trans <- lapply(1:length(transList@transforms), function(x) {
          transList@transforms[[x]]@f
        })
        names(trans) <- names(transList@transforms)

        # Convert to transform objects
        trans <- lapply(1:length(trans), function(x) {
          t <- new("transform", .Data = trans[[1]])
          t@transformationId <- names(trans)[x]

          return(t)
        })

        trans <- lapply(trans, function(t) {
          inv <- flowCore::inverseLogicleTransform(trans = t)
          flowWorkspace::flow_trans("logicle", t@.Data, inv@.Data)
        })
        names(trans) <- names(transList@transforms)
        transList <- flowWorkspace::transformerList(names(trans), trans)
      }

      # check which channels are covered by transList
      chans <- names(transList)

      # gatingSet contains some transformations
      if (length(x@transformation) != 0) {
        trnsfrms <- lapply(channels, function(channel) {
          getTransformations(x[[1]], channel, only.function = FALSE)
        })
        names(trnsfrms) <- channels

        # Remove NULL transforms
        trnsfrms[sapply(trnsfrms, is.null)] <- NULL
        trnsLst <- transformerList(names(trnsfrms), trnsfrms)

        # GatingSet contains some transformations
        if (any(channels %in% names(trnsLst))) {

          # GatingSet contains all transformations
          if (all(channels %in% names(trnsLst))) {
            return(trnsLst)
          } else {

            # GatingSet contains some transformations
            trnsLst <- trnsLst[names(trnsLst) %in% channels]

            # See if transList has any additional transformations
            if (any(names(transList) %in% channels[!channels %in% names(trnsLst)])) {
              transList <- flowWorkspace::transformerList(names(transList[names(transList) %in% channels[!channels %in% names(trnsLst)]]), transList[names(transList) %in% channels[!channels %in% names(trnsLst)]])
              trnsLst <- c(trnsLst, transList)
              trnsLst <- flowWorkspace::transformerList(names(trnsLst), trnsLst)
            }

            # See if all transformations are now present
            if (all(channels %in% names(trnsLst))) {
              return(trnsLst)
            } else {

              # Some channels are still missing transformations
              fs <- flowWorkspace::getData(x, "root")
              fr <- as(fs, "flowFrame")
              fs <- flowCore::flowSet(fr)
              gs <- suppressMessages(flowWorkspace::GatingSet(fs))

              transList <- flowCore::estimateLogicle(gs[[1]], channels[!channels %in% names(trnsLst)])
              transList <- c(trnsLst, transList)
              transList <- flowWorkspace::transformerList(names(transList), transList)

              return(transList)
            }
          }
        }

        # GatingSet has no transformations
      } else if (length(x@transformation) == 0) {

        # transList contains all transformations
        if (all(channels %in% chans)) {
          return(transList)

          # Get remaining transformations from GatingSet using estimateLogicle
        } else {

          # Get remaining transformations with estimateLogicle
          fs <- flowWorkspace::getData(x, "root")
          fr <- as(fs, "flowFrame")
          fs <- flowCore::flowSet(fr)
          gs <- suppressMessages(flowWorkspace::GatingSet(fs))

          trnsLst <- flowCore::estimateLogicle(gs[[1]], channels[!channels %in% chans])
          transList <- c(trnsLst, transList)
          transList <- flowWorkspace::transformerList(names(transList), transList)

          return(transList)
        }
      }
    }
  }
}

#' .getTransformedData
#' return data which is appropriately transformed (fluorescent channels) - flowFrame/flowSet/GatingSet
#' @noRd
.getTransformedData <- function(x, transList = NULL) {

  # Only flowFrame/flowSet/GatingSet
  if (!any(inherits(x, "flowFrame") | inherits(x, "flowSet") | inherits(x, "GatingSet"))) {
    stop("x must be either a flowFrame, flowSet or GatingSet. Subsetted GatingSet should be used instead of GatingHierarchy.")
  }

  # Get comlete transList
  transList <- .getCompleteTransList(x, transList)

  # Extract channels which have transformations
  if (inherits(transList, "transformList")) {
    chans <- names(transList@transforms)
  } else if (inherits(transList, "transformerList")) {
    chans <- names(transList)
  }

  # Extract summary stats
  if (inherits(x, "flowFrame")) {
    sm <- flowWorkspace::pData(flowCore::parameters(x))
  } else if (inherits(x, "flowSet")) {
    sm <- flowWorkspace::pData(flowCore::parameters(x[[1]]))
  } else if (inherits(x, "GatingSet")) {
    sm <- flowWorkspace::pData(flowCore::parameters(flowWorkspace::getData(x, "root")[[1]]))
  }

  # Extract channels that have been transformed
  chns <- sm[, "name"][sm[, "maxRange"] < 6]

  # Check all chans have been transformed
  if (length(chns) == 0) {

    # No channels transformed
    x <- flowCore::transform(x, transList)
  } else if (all(chans %in% chns)) {

    # All channels have been transformed
  } else {

    # Get transformations for untransformed channels
    if (inherits(transList, "transformList")) {
      transList <- flowCore::transformList(chans[!chans %in% chns], transList@transforms[chans[!chans %in% chns]][[1]]@f)
    } else if (inherits(transList, "transformerList")) {
      transList <- flowWorkspace::transformerList(chans[!chans %in% chns], transList[chans[!chans %in% chns]])
    }

    # Some channels have been transformed
    x <- suppressMessages(flowCore::transform(x, transList))
  }

  return(x)
}

#' .getRawData
#' return data which is untransformed - flowFrame/flowSet/GatingSet
#' GatingSet returns a flowSet of untransformed data at parent node
#' @noRd
.getRawData <- function(x, transList = NULL, parent = "root") {

  # Only flowFrame/flowSet/GatingSet
  if (!any(inherits(x, "flowFrame") | inherits(x, "flowSet") | inherits(x, "GatingSet"))) {
    stop("x must be either a flowFrame, flowSet or GatingSet. Subsetted GatingSet should be used instead of GatingHierarchy.")
  }

  # Data is untransformed
  if (.checkDataTransform(x) == FALSE) {
    if (inherits(x, "flowFrame") | inherits(x, "flowSet")) {
      return(x)
    } else if (inherits(x, "GatingSet")) {
      return(flowWorkspace::getData(x, parent))
    }

    # Data is transformed
  } else {
    if (inherits(x, "flowFrame") | inherits(x, "flowSet")) {
      if (is.null(transList)) {
        stop("Supply a transList object to inverse transformations.")
      }
    }
  }

  # Extract transformations from GatingSet
  if (is.null(transList) & inherits(x, "GatingSet")) {
    channels <- colnames(x)

    trnsfrms <- lapply(channels, function(channel) {
      getTransformations(x[[1]], channel, only.function = FALSE)
    })
    names(trnsfrms) <- channels

    # Remove NULL transforms
    trnsfrms[sapply(trnsfrms, is.null)] <- NULL
    transList <- transformerList(names(trnsfrms), trnsfrms)
  }

  # Get inverse transList
  inv <- checkTransList(transList, inverse = TRUE)

  # Extract channels which have transformations
  if (inherits(transList, "transformList")) {
    chans <- names(transList@transforms)
  } else if (inherits(transList, "transformerList")) {
    chans <- names(transList)
  }

  # Extract summary stats
  if (inherits(x, "flowFrame")) {
    sm <- flowWorkspace::pData(flowCore::parameters(x))
  } else if (inherits(x, "flowSet")) {
    sm <- flowWorkspace::pData(flowCore::parameters(x[[1]]))
  } else if (inherits(x, "GatingSet")) {
    sm <- flowWorkspace::pData(flowCore::parameters(flowWorkspace::getData(x, "root")[[1]]))
  }

  # Extract channels that have been transformed - apply inverse transform
  chns <- as.vector(sm[, "name"][sm[, "maxRange"] < 6])

  # Extract flowSet from GatingSet
  if (inherits(x, "GatingSet")) {
    x <- flowWorkspace::getData(x, parent)
  }

  # Check all chans have been transformed
  if (length(chns) == 0) {

    # No channels transformed
  } else if (all(chans %in% chns)) {

    # All channels have been transformed
    x <- flowCore::transform(x, inv)
  } else {

    # Some channels have been transformed
    trns <- lapply(chans[chans %in% chns], function(x) {
      inv@transforms[[x]]@f
    })
    names(trns) <- chans[chans %in% chns]
    inv <- transformList(names(trns), trns)
    x <- flowCore::transform(x, inv)
  }

  return(x)
}

#' .checkDataTransform
#' Check whether data has been transfomed - return TRUE if any channels transformed
#' @noRd
.checkDataTransform <- function(x) {
  if (inherits(x, "flowFrame")) {

    # Extract summary stats
    sm <- pData(parameters(x))

    # Check if any maxRange < 6
    if (any(sm[, "maxRange"] < 6)) {
      return(TRUE)
    } else {
      return(FALSE)
    }
  } else if (inherits(x, "flowSet")) {

    # Extract summary stats
    sm <- pData(parameters(x[[1]]))

    # Check if any maxRange < 6
    if (any(sm[, "maxRange"] < 6)) {
      return(TRUE)
    } else {
      return(FALSE)
    }
  } else if (inherits(x, "GatingSet")) {

    # Extract root flowSet
    fs <- getData(x, "root")

    # Extract summary stats
    sm <- pData(parameters(fs[[1]]))

    # Check if any maxRange < 6
    if (any(sm[, "maxRange"] < 6)) {
      return(TRUE)
    } else {
      return(FALSE)
    }
  }
}
