#' Compute Spillover Matrix
#'
#' \code{computeSpillover} uses the method described by Bagwell & Adams 1993 to
#' calculate the fluorescent spillover matrix using a reference universal
#' unstained control and single stain compensation controls.
#'
#' \code{computeSpillover} begins by the user selecting which fluorescent
#' channel is associated with each control from a dropdown menu. Following
#' channel selection, \code{computeSpillover} runs through each control and
#' plots the density distribution of the unstained control in red and the
#' compensation control in blue. Users can then gate the positive signal for
#' spillover calculation using an interval gate. The percentage spillover is
#' calculated based on the median fluorescent intensities of the stained
#' populations and the universal unstained sample. The computed spillover matrix
#' is returned as an r object and written to a named .csv file for future use.
#' \code{computeSpillover} has methods for both
#' \code{\link[flowCore:flowSet-class]{flowSet}} and
#' \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} objects so refer to
#' their respective help pages for more information.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}}.
#' @param ... additional method-specific arguments for computeSpillover.
#'
#' @seealso \code{\link{computeSpillover,flowSet-method}}
#' @seealso \code{\link{computeSpillover,GatingSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @references C. B. Bagwell \& E. G. Adams (1993). Fluorescence spectral
#'   overlap compensation for any number of flow cytometry parameters. in:
#'   Annals of the New York Academy of Sciences, 677:167-184.
#'
#' @export
setGeneric(name="computeSpillover",
           def=function(x, ...){standardGeneric("computeSpillover")}
)

#' Compute Spillover Matrix - flowSet Method
#'
#' \code{computeSpillover} uses the method described by Bagwell & Adams 1993 to
#' calculate the fluorescent spillover matrix using a reference universal
#' unstained control and single stain compensation controls.
#'
#' Calculate spillover matrix using
#' \code{\link[flowCore:flowSet-class]{flowSet}} containing gated single stain
#' compensation controls and an unstained control. \code{computeSpillover}
#' begins by the user selecting which fluorescent channel is associated with
#' each control from a dropdown menu. Following channel selection,
#' \code{computeSpillover} runs through each control and plots the density
#' distribution of the unstained control in red and the compensation control in
#' blue. Users can then gate the positive signal for spillover calculation using
#' an interval gate. The percentage spillover is calculated based on the median
#' fluorescent intensities of the stained populations and the universal
#' unstained sample. The computed spillover matrix is returned as an r object
#' and written to a named .csv file for future use.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}
#'   containing pre-gated single stain compensation controls and a universal
#'   unstained control. Currently, computeSpillover does not pre-gate samples to
#'   obtain a homogeneous cell population for downstream calculations. We
#'   therefore recommmend pre-gating samples based on FSC and SSC parameters
#'   prior to passing them to computeSpillover (i.e. \code{x} should contain
#'   events for single cells only). Passing raw files to computeSpillover will
#'   result in inaccurate calculations of fluorescent spillover matrix.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} generated by
#'   \code{estimateLogicle} to transform fluorescent channels for gating.
#'   \code{transList} is required if logicle transformation has already been
#'   applied to \code{x} using estimateLogicle. \code{computeSpillover} will
#'   automatically call \code{\link[flowCore:logicleTransform]{estimateLogicle}}
#'   internally to transform channels prior to gating, if \code{transList} is
#'   supplied it will be used for the transformation instead.
#' @param cmfile name of .csv file containing the names of the samples in a
#'   column called "name" and their matching channel in a column called
#'   "channel". \code{computeSpillover} will the guide you through the channel
#'   selection process and generate a channel match file called "Compensation
#'   Channels.csv" automatically. If you already have a complete cmfile and
#'   would like to bypass the channel selection process, simply pass the name of
#'   the cmfile to this argument (e.g. "Compensation Channels.csv").
#' @param spfile name of the output spillover csv file, set to \code{"Spillover
#'   Matrix.csv"} by default.
#' @param ... additional arguments passed to \code{\link{plotCyto1d,flowFrame-method}}
#' and \code{\link{plotCyto1d,flowSet-method}}.
#'
#' @return spillover matrix object and \code{"Spillover Matrix.csv"} file.
#'
#' @examples
#' \dontrun{
#' fs <- Activation
#' gate1 <- drawGate(fs, alias = "Cells", channels = c("FSC-A","SSC-A"))
#' Cells <- Subset(fs, g1[[1]])
#' gate2 <- drawGate(Cells, alias = "Singlets", channels = c("FSC-A","FSC-H"))
#' Singlets <- Subset(Cells, g2[[1]])
#' spill <- computeSpillover(Singlets, spfile = "Example Spillover Matrix.csv")
#' }
#'
#' @importFrom flowCore estimateLogicle transform each_col fsApply
#'   inverseLogicleTransform sampleNames flowSet
#' @importFrom flowWorkspace pData GatingSet
#' @importFrom methods as
#' @importFrom utils read.csv write.csv
#' @importFrom stats median
#'
#' @seealso \code{\link{plotCyto1d,flowFrame-method}}
#' @seealso \code{\link{plotCyto1d,flowSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @references C. B. Bagwell \& E. G. Adams (1993). Fluorescence spectral
#'   overlap compensation for any number of flow cytometry parameters. in:
#'   Annals of the New York Academy of Sciences, 677:167-184.
#'
#' @export
setMethod(computeSpillover, signature = "flowSet", definition = function(x, transList = NULL, cmfile = NULL, spfile = "Spillover Matrix.csv", ...){
  
  # Assign x to fs
  fs <- x
  
  # Extract pData information
  pd <- pData(fs)
  
  # Extract fluorescent channels
  channels <- getChannels(fs)
  
  # Select a fluorescent channel for each compensation control
  if(is.null(cmfile)){
    
    pd$channel <- paste(selectChannels(fs))
    write.csv(pd, "Compensation Channels.csv", row.names = FALSE)
    
  }else{
    
    cm <- read.csv(cmfile, header = TRUE, row.names = 1)
    chans <- cm$channel[match(sampleNames(fs), row.names(cm))]
    pd$channel <- paste(chans)
    
  }
  
  # Merge files for use with estimateLogicle
  fr <- as(fs, "flowFrame")
  
  # Extract summary statistics
  sm <- pData(parameters(fr))
  
  # Check transList
  if(!is.null(transList)){
    
    # Get complete transformList object
    transList <- .getCompleteTransList(fr, transList = transList)
  
  }
  
  # All channels not transformed - maxRange > 10
  if(all(sm[, "maxRange"][sm$name %in% channels] > 10)){
    
    # Use transList if supplied
    if(!is.null(transList)){
      
      # TransList contains all transformations
      fs <- suppressMessages(transform(fs, transList))
      
    }else if(is.null(transList)){
      
      # Use estimateLogicle to transform all channels
      transList <- estimateLogicle(fr, channels)
      fs <- suppressMessages(transform(fs, transList))
      
    }
    
    # All channels transformed - maxRange < 10
  }else if(all(sm[, "maxRange"][sm$name %in% channels] < 10)){
    
    # All fluorescent channels have been transformed - transList complete
    
  # Some channels have been transformed - some maxRange > 10
  }else if(any(sm[, "maxRange"][sm$name %in% channels] > 10)){
    
    # Which channels have NOT been transformed?
    chns <- channels[sm[, "maxRange"][sm$name %in% channels] > 10]
    
    # transform these channels using transList
    fs <- suppressMessages(transform(fs, transList@transforms[chns]))
    
  }
  
  # Extract unstained control based on selected channels in pData(fs)
  NIL <- fs[[match("Unstained", pd$channel)]]
  fs <- fs[-match("Unstained", pd$channel)]
  
  # Names
  nms <- sampleNames(fs)
  
  # Samples
  smp <- length(fs)
  
  # Remove NIL from pd
  pd <- pd[!pd$channel == "Unstained",]
  
  # Gate positive populations
  pops <- lapply(seq(1,smp,1), function(x){
    
    # Extract flowFrame
    fr <- fs[[x]]
    
    # Channel
    chan <- pd$channel[x]
    
    # Plot
    plotCyto(NIL, channels = chan, overlay = fr, offset = 0, transList = transList, popup = TRUE, fill = c("red","dodgerblue"), legend = FALSE, alpha = 0.6, main = nms[x], ...)
    
    # Call drawGate on each flowFrame using interval gate on selected channel
    if(getOption("CytoRSuite_interact") == TRUE){
      
      gt <- drawGate(x = fr, alias = paste(chan,"+"), channels = chan, type = "interval", adjust = 1.5, plot = FALSE)
      fr <- Subset(fr, gt[[1]])
      
    }
    
    return(fr)
  })
  names(pops) <- nms
  pops <- flowSet(pops)
  
  # Inverse logicle transformation
  inv <-  inverseLogicleTransform(transList)
  pops <- suppressMessages(transform(pops, inv))
  NIL <- suppressMessages(transform(NIL, inv))
  
  # Calculate MedFI for all channels for unstained control
  neg <- each_col(NIL, median)[channels]
  
  # Calculate MedFI for all channels for all stained controls
  pos <- fsApply(pops, each_col, median)[,channels]
  
  # Subtract background fluorescence
  signal <- sweep(pos, 2, neg)
  
  # Construct spillover matrix - only include values for which there is a control
  spill <- diag(x = 1, nrow = length(channels), ncol = length(channels))  
  colnames(spill) <- channels
  rownames(spill) <- channels
  
  # Normalise each row to stained channel
  lapply(seq(1,nrow(signal),1), function(x){
    
    signal[x, ] <<- signal[x, ]/signal[x, match(pd$channel[x], colnames(spill))]
    
  }) 
  
  # Insert values into appropriate rows
  rws <- match(pd$channel, rownames(spill))
  spill[rws,] <- signal
  
  write.csv(spill, spfile)
  return(spill)
  
})

#' Compute Spillover Matrix - GatingSet Method
#'
#' \code{computeSpillover} uses the method described by Bagwell & Adams 1993 to
#' calculate the fluorescent spillover matrix using a reference universal
#' unstained control and single stain compensation controls.
#'
#' Calculate spillover matrix using
#' \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing gated
#' single stain compensation controls and an unstained control.
#' \code{computeSpillover} uses the method described by Bagwell & Adams 1993 to
#' calculate fluorescent spillover values using single stain compensation
#' controls and a universal unstained control. \code{computeSpillover} begins by
#' the user selecting which fluorescent channel is associated with each control
#' from a dropdown menu. Following channel selection, \code{computeSpillover}
#' runs through each control and plots the density distribution of the unstained
#' control in red and the compensation control in blue. Users can then gate the
#' positive signal for spillover calculation using an interval gate. The
#' percentage spillover is calculated based on the median fluorescent
#' intensities of the stained populations and the universal unstained sample.
#' The computed spillover matrix is returned as an r object and written to a
#' named .csv file for future use.
#'
#' @param x object of class
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing pre-gated
#'   single stain compensation controls and a universal unstained control.
#'   Currently, computeSpillover does not pre-gate samples to obtain a
#'   homogeneous cell population for downstream calculations. We therefore
#'   recommmend pre-gating samples based on FSC and SSC parameters prior to
#'   passing them to computeSpillover and indicate the population of interest
#'   using the \code{parent} argument.
#' @param parent name of the pre-gated population to use for downstream
#'   calculations, set to the last node of the GatingSet by default (e.g.
#'   "Single Cells").
#' @param transList object of class
#'   \code{\link[flowWorkspace:transformerList]{transformerList}} generated by
#'   \code{estimateLogicle} to transform fluorescent channels for gating.
#'   \code{transList} is required if logicle transformation has already been
#'   applied to \code{x} using estimateLogicle. \code{computeSpillover} will
#'   automatically call \code{\link[flowCore:logicleTransform]{estimateLogicle}}
#'   internally to transform channels prior to gating, if \code{transList} is
#'   supplied it will be used for the transformation instead.
#' @param cmfile name of .csv file containing the names of the samples in a
#'   column called "name" and their matching channel in a column called
#'   "channel". \code{computeSpillover} will the guide you through the channel
#'   selection process and generate a channel match file called "Compensation
#'   Channels.csv" automatically. If you already have a complete cmfile and
#'   would like to bypass the channel selection process, simply pass the name of
#'   the cmfile to this argument (e.g. "Compensation Channels.csv").
#' @param spfile name of the output spillover csv file, set to \code{"Spillover
#'   Matrix.csv"} by default.
#' @param ... additional arguments passed to \code{\link{plotCyto1d,flowFrame-method}}
#' and \code{\link{plotCyto1d,flowSet-method}}.
#'
#' @return spillover matrix object and \code{"Spillover Matrix.csv"} file.
#'
#' @examples
#' \dontrun{
#' fs <- Activation
#' gs <- GatingSet(fs)
#' drawGate(gs, 
#'          parent = "root", 
#'          parent = "Cells", 
#'          channels = c("FSC-A","SSC-A"), 
#'          gtfile = "Example gatingTemplate.csv")
#' drawGate(gs, 
#'          parent = "Cells", 
#'          parent = "Singlets", 
#'          channels = c("FSC-A","FSC-H"), 
#'          gtfile = "Example gatingTemplate.csv")
#' spill <- computeSpillover(gs, 
#'                           parent = "Single Cells", 
#'                           spfile = "Example Spillover Matrix.csv")
#' }
#'
#' @importFrom flowCore estimateLogicle transform each_col fsApply
#'   inverseLogicleTransform flowSet
#' @importFrom flowWorkspace getData pData getTransformations GatingSet
#' @importFrom methods as
#'
#' @seealso \code{\link{plotCyto1d,flowFrame-method}}
#' @seealso \code{\link{plotCyto1d,flowSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @references C. B. Bagwell \& E. G. Adams (1993). Fluorescence spectral
#'   overlap compensation for any number of flow cytometry parameters. in:
#'   Annals of the New York Academy of Sciences, 677:167-184.
#'
#' @export
setMethod(computeSpillover, signature = "GatingSet", definition = function(x, parent = NULL, transList = NULL, cmfile = NULL, spfile = "Spillover Matrix.csv", ...){
  
  gs <- x
  
  # Extract Population for Downstream Analyses
  if(!is.null(parent)){
    
    fs <- getData(gs, parent)
    
  }else if(is.null(parent)){
    
    fs <- getData(gs, getNodes(gs)[length(getNodes(gs))])
    
  }
  
  # Merge files for use with estimateLogicle
  fr <- as(fs, "flowFrame")
  fs.m <- flowSet(fr)
  gs.m <- suppressMessages(GatingSet(fs.m))
  
  # Extract fluorescent channels
  channels <- getChannels(gs)
  
  if(!is.null(transList)){
    
    transList <- .getCompleteTransList(gs, transList = transList)
    
  }
  
  # Extract transformations if NULL apply transList
  trnsfrms <- lapply(channels, function(channel){getTransformations(gs[[1]], channel, only.function = FALSE)})
  names(trnsfrms) <- channels
  
  # Remove NULL transforms
  trnsfrms[sapply(trnsfrms, is.null)] <- NULL
  
  if(length(trnsfrms) == 0){
    
    trnsfrms <- NULL
    
  }
  
  # Convert to transformerList
  if(!is.null(trnsfrms)){
    
    trnsLst <- transformerList(names(trnsfrms), trnsfrms)
    
  }
  
  # No transformations extracted from GatingSet
  if(is.null(trnsfrms)){
    
    # Check if transList has been supplied and contains all channels
    if(!is.null(transList)){
        
      # TransList contains transformations for all channels
      gs <- suppressMessages(transform(gs, transList))
      
    }else if(is.null(transList)){
      
      # No transformations applied and no transList supplied
      transList <- estimateLogicle(gs.m[[1]], channels)
      gs <- suppressMessages(transform(gs, transList))
      
    }
    
    # Some transformations were extracted from GatingSet 
  }else if(!is.null(trnsfrms)){
    
    if(all(channels %in% names(trnsLst))){
      
      # All transformations were extracted from GatingSet
      
    }else if(!all(channels %in% names(trnsLst))){
      
      # Not all channels have been transformed in the GatingSet
      chans <- channels[!channels %in% names(trnsLst)]
      
      # Try get transformations from transList
      if(!is.null(transList)){
        
        if(all(chans %in% names(transList))){
          
          # All missing transformations are in transList
          trns <- transformerList(names(transList[chans]), transList[chans])
          gs <- suppressMessages(transform(gs, trns))
          
          # Update transList
          transList <- c(trnsLst, trns)
          
        }else if(!all(chans %in% names(transList))){
          
          # Not all of the remaining channels are in transList
          if(any(chans %in% names(transList))){
            
            # Some channels are in transList
            chnls <- chans[chans %in% names(transList)]
            trns <- transformerList(names(transList[chnls]), transList[chnls])
            gs <- suppressMessages(transform(gs, trns))
            transList <- c(trnsLst, trns)
            
            # Get remaining transformations using estimateLogicle
            chnls <- chans[!chans %in% names(transList)]
            trns <- estimateLogicle(gs.m[[1]], chnls)
            gs <- suppressMessages(transform(gs, trns))
            transList <- c(transList, trns)
            
            
          }else if(!any(chans %in% names(transList))){
            
            # No missing channels are in transList need to use estimateLogicle
            trns <- estimateLogicle(gs.m[[1]], chans)
            gs <- suppressMessages(transform(gs, trns))
            transList <- c(trnsLst, trns)
            
          }
          
        }
        
        # No transList supplied - use estimateLogicle 
      }else if(is.null(transList)){
        
        # Get remaining transformations using estimateLogicle
        chns <- channels[!channels %in% names(trnsLst)]
        trns <- estimateLogicle(gs.m[[1]], chns)
        gs <- suppressMessages(transform(gs, trns))
        transList <- c(trnsLst, trns)
        
      }
      
    }
    
  }
  
  # Get complete transformerList
  transList <- checkTransList(transList, inverse = FALSE)
  
  # Extract Transformed flowSet for Downstream Analyses
  if(!is.null(parent)){
    
    fs <- getData(gs, parent)
    
  }else if(is.null(parent)){
    
    fs <- getData(gs, getNodes(gs)[length(getNodes(gs))])
    
  }
  
  computeSpillover(x = fs, transList = transList, cmfile = cmfile, spfile = spfile, ...)
  
})

#' .getCompleteTransList
#' return compltete transList for flowFrame, flowSet or GatingSet
#' @noRd
.getCompleteTransList <- function(x, transList = NULL){

  # Check class of transList
  if(!is.null(transList)){
    
    if(!class(transList)[1] %in% c("transformList","transformerList")){
      
      stop("Supplied transList should be of class transformList or transformerList.")
      
    }
    
  }
  
  # Extract fluorescent channels
  channels <- getChannels(x)
  
  # If NULL transList get all transformations
  if(is.null(transList)){
    
    if(inherits(x, "flowFrame")){
      
      transList <- flowCore::estimateLogicle(x, channels)
      return(transList)
      
    }else if(inherits(x, "flowSet")){
      
      transList <- flowCore::estimateLogicle(as(x, "flowFrame"), channels)
      return(transList)
      
    }else if(inherits(x, "GatingSet")){
      
      # GatingSet contains all transformations
      if(all(channels %in% names(x@transformation[[1]]))){
        
        # Some transforms found - replace these entries in transList
        trnsfrms <- lapply(channels, function(channel){getTransformations(x[[1]], channel, only.function = FALSE)})
        names(trnsfrms) <- channels
        
        # Remove NULL transforms
        trnsfrms[sapply(trnsfrms, is.null)] <- NULL
        transList <- transformerList(names(trnsfrms), trnsfrms)
        
        return(transList)
        
      }else if(length(names(x@transformation[[1]])) == 0){
        
        # GatingSet is not transformed
        fs <- flowWorkspace::getData(x, "root")
        fr <- as(fs, "flowFrame")
        fs <- flowCore::flowSet(fr)
        gs <- suppressMessages(flowWorkspace::GatingSet(fs))
      
        transList <- flowCore::estimateLogicle(gs[[1]], channels)
        return(transList)
        
      }else{
        
        # GatingSet contains some transformations
        trnsfrms <- lapply(channels, function(channel){getTransformations(x[[1]], channel, only.function = FALSE)})
        names(trnsfrms) <- channels
        
        # Remove NULL transforms
        trnsfrms[sapply(trnsfrms, is.null)] <- NULL
        trnsLst <- transformerList(names(trnsfrms), trnsfrms)
        
        # Get remaining transformations with estimateLogicle
        fs <- flowWorkspace::getData(x, "root")
        fr <- as(fs, "flowFrame")
        fs <- flowCore::flowSet(fr)
        gs <- suppressMessages(flowWorkspace::GatingSet(fs))
        
        transList <- flowCore::estimateLogicle(gs[[1]], channels[!channels %in% names(trnsLst)])
        transList <- c(trnsLst, transList)
        return(transList)
        
      }
      
    }
    
  }
  
  # flowFrame or flowSet return transformList
  if(inherits(x, "flowFrame") | inherits(x, "flowSet")){
    
    # Run checkTransList to get transformList
    transList <- checkTransList(transList = transList, inverse = FALSE)
    
    # Check which channels have been transformed
    chans <- names(transList@transforms)
    
    # TransList contains transformation for all fluorescent channels
    if(all(channels %in% chans)){
      
      # TransList is complete
      return(transList)
     
    # Some fluorescent channels don't have transformations 
    }else{
      
      # Convert x to flowSet
      if(inherits(x, "flowFrame")){
        
        fs <- flowCore::flowSet(x)
        
      }else if(inherits(x, "flowSet")){
        
        fs <- x
        
      }
    
      # Generate merged flowFrame for use with estimateLogicle
      fr <- as(fs, "flowFrame")
    
      # Find channels excluded from transList
      excl <- channels[!channels %in% chans]
      
      # Get transformations for these channels using estimateLogicle
      trans <- flowCore::estimateLogicle(fr, excl)
      
      # Combine supplied transList with add transformations
      nms <- c(names(transList@transforms), excl)
      transList <- c(transList, trans)
      names(transList@transforms) <- nms
      
      return(transList)
      
    }
    
  # GatingSet return transformerList
  }else if(inherits(x, "GatingSet")){
    
    # Supplied transList is a transformList - convert to transformerList
    if(inherits(transList, "transformList")){
      
      # Get transform functions
      trans <- lapply(1:length(names(transList@transforms)), function(x){transList@transforms[[x]]@f})
      names(trans) <- names(transList@transforms)
      
      # Convert to transform objects
      trans <- lapply(1:length(trans), function(x) {
        
        t <- new("transform", .Data = trans[[1]])
        t@transformationId <- names(trans)[x]
        
        return(t)
        
      })
      
      trans <- lapply(trans, function(t){
        inv <- flowCore::inverseLogicleTransform(trans = t)
        flowWorkspace::flow_trans("logicle", t@.Data, inv@.Data)
      })
      names(trans) <- names(transList@transforms)
      transList <- flowWorkspace::transformerList(names(trans), trans)
      
    }

    # check which channels have transformations
    chans <- names(transList)
    
    # Extract transformations from GatingSet
    if(length(x@transformation) == 0){
      
      # No transformations found in GatingSet
      transList <- transList
      
    }else{
      
      # Some transforms found - replace these entries in transList
      trnsfrms <- lapply(channels, function(channel){getTransformations(x[[1]], channel, only.function = FALSE)})
      names(trnsfrms) <- channels
      
      # Remove NULL transforms
      trnsfrms[sapply(trnsfrms, is.null)] <- NULL
      trnsLst <- transformerList(names(trnsfrms), trnsfrms)
      
      # All channels are transformed in GatingSet
      if(length(channels[!channels %in% names(trnsLst)]) == 0){
      
        transList <- trnsLst
        
      }else{
      
        # Replace entries in transList with trnsLst
        transList <- c(trnsLst, transformerList(channels[!channels %in% names(trnsLst)], transList[channels[!channels %in% names(trnsLst)]]))
      
      }
      
    }
    
    # transformerList contains transformation for all channels
    if(all(channels %in% chans)){
      
      # transList is complete
      return(transList)
     
    # transList is missing some transformations   
    }else{
      
      # Extract root flowSet
      fs <- flowWorkspace::getData(x, "root")
      
      # Generate merged flowFrame for use with estimateLogicle
      fr <- as(fs, "flowFrame")
      
      # fr to flowSet
      fs <- flowCore::flowSet(fr)
      
      # GatingSet
      gs <- flowWorkspace::GatingSet(fs)
      
      # Find channels excluded from transList
      excl <- channels[!channels %in% chans]
      
      # Get transformations for these channels using estimateLogicle
      trans <- flowCore::estimateLogicle(gs[[1]], excl)
      
      # Combine supplied transList with add transformations
      transList <- c(transList, trans)
      
      return(transList)
      
    }
    
  }
  
}

#' .getTransformedData
#' return data which is appropriately transformed (fluorescent channels) - flowFrame/flowSet/GatingSet
#' @noRd
.getTransformedData <- function(x, transList = NULL){
  
  # Only flowFrame/flowSet/GatingSet
  if(!class(x)[1] %in% c("flowFrame", "flowSet", "GatingSet")){
    
    stop("x must be either a flowFrame, flowSet or GatingSet. Subsetted GatingSet should be used instead of GatingHierarchy.")
    
  }
  
  # Get comlete transList
  transList <- .getCompleteTransList(x, transList)
  
  # Extract channels which have transformations
  if(inherits(transList, "transformList")){
    
    chans <- names(transList@transforms)
    
  }else if(inherits(transList, "transformerList")){
    
    chans <- names(transList)
    
  }
  
  # Extract summary stats
  if(inherits(x, "flowFrame")){
    
    sm <- flowWorkspace::pData(flowCore::parameters(x))
    
  }else if(inherits(x, "flowSet")){
    
    sm <- flowWorkspace::pData(flowCore::parameters(x[[1]]))
    
  }else if(inherits(x, "GatingSet")){
    
    sm <- flowWorkspace::pData(flowCore::parameters(flowWorkspace::getData(x, "root")[[1]]))
    
  }
      
  # Extract channels that have been transformed
  chns <- sm[, "name"][sm[,"maxRange"] < 6]
      
  # Check all chans have been transformed
  if(length(chns) == 0){
        
    # No channels transformed
    x <- flowCore::transform(x, transList)

  }else if(all(chans %in% chns)){
        
    # All channels have been transformed

  }else{
        
    # Get transformations for untransformed channels
    if(inherits(transList, "transformList")){
      
      transList <- flowCore::transformList(chans[!chans %in% chns], transList@transforms[chans[!chans %in% chns]][[1]]@f)
      
    }else if(inherits(transList, "transformerList")){
      
      transList <- flowWorkspace::transformerList(chans[!chans %in% chns], transList[chans[!chans %in% chns]])
      
    }
    
    # Some channels have been transformed
    x <- flowCore::transform(x, transList)
        
  }
  
  return(x)
  
}

#' .getRawData
#' return data which is untransformed - flowFrame/flowSet/GatingSet
#' GatingSet returns a flowSet of untransformed data at parent node
#' @noRd
.getRawData <- function(x, transList = NULL, parent = "root"){
  
  # need transList for inverse transform
  if(inherits(x, "flowFrame") | inherits(x, "flowSet") & is.null(transList) & .checkDataTransform(x) == TRUE){
    
    stop("Supply a transList object to inverse transformations.")
    
  }else if(inherits(x, "flowFrame") | inherits(x, "flowSet") & .checkDataTransform(x) == FALSE){
    
    # Data is not transformed
    return(x)
    
  }
  
  # Only flowFrame/flowSet/GatingSet
  if(!class(x)[1] %in% c("flowFrame", "flowSet", "GatingSet")){
    
    stop("x must be either a flowFrame, flowSet or GatingSet. Subsetted GatingSet should be used instead of GatingHierarchy.")
    
  }
  
  # Get complete transList
  transList <- .getCompleteTransList(x, transList)

  # Get inverse transList
  inv <- checkTransList(transList, inverse = TRUE)
  
  # Extract channels which have transformations
  if(inherits(transList, "transformList")){
    
    chans <- names(transList@transforms)
    
  }else if(inherits(transList, "transformerList")){
    
    chans <- names(transList)
    
  }
  
  # Extract summary stats
  if(inherits(x, "flowFrame")){
    
    sm <- flowWorkspace::pData(flowCore::parameters(x))
    
  }else if(inherits(x, "flowSet")){
    
    sm <- flowWorkspace::pData(flowCore::parameters(as(x,"flowset")[[1]]))
    
  }else if(inherits(x, "GatingSet")){
    
    sm <- flowWorkspace::pData(flowCore::parameters(flowWorkspace::getData(x, "root")[[1]]))
    
  }
  
  # Extract channels that have been transformed - apply inverse transform
  chns <- sm[, "name"][sm[,"maxRange"] < 6]
  
  # Extract flowSet from GatingSet
  if(inherits(x, "GatingSet")){
    
    x <- flowWorkspace::getData(x, parent)
    
  }  
  
  # Check all chans have been transformed
  if(length(chns) == 0){
    
    # No channels transformed
    
  }else if(all(chans %in% chns)){
    
    # All channels have been transformed
    x <- flowCore::transform(x, inv)
    
  }else{
    
    # Some channels have been transformed
    x <- flowCore::transform(x, inv[chans[chans %in% chns]])
    
  }

  return(x)
  
}

#' .checkDataTransform
#' Check whether data has been transfomed - return TRUE if any channels transformed
#' @noRd
.checkDataTransform <- function(x){
  
  if(inherits(x, "flowFrame")){
    
    # Extract summary stats
    sm <- pData(parameters(x))
    
    # Check if any maxRange < 6
    if(any(sm[,"maxRange"] < 6)){
      
      return(TRUE)
      
    }else{
      
      return(FALSE)
      
    }
    
  }else if(inherits(x, "flowSet")){
    
    # Extract summary stats
    sm <- pData(parameters(x[[1]]))
    
    # Check if any maxRange < 6
    if(any(sm[,"maxRange"] < 6)){
      
      return(TRUE)
      
    }else{
      
      return(FALSE)
      
    }
    
  }else if(inherits(x, "GatingSet")){
    
    # Extract root flowSet
    fs <- getData(gs, "root")
    
    # Extract summary stats
    sm <- pData(parameters(fs[[1]]))
    
    # Check if any maxRange < 6
    if(any(sm[,"maxRange"] < 6)){
      
      return(TRUE)
      
    }else{
      
      return(FALSE)
      
    }
    
  }
  
}
